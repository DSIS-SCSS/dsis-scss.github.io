{"pages":[{},{},{},{},{},{},{}],"posts":[{"title":"机器学习学习笔记（持续更新）","date":"2022-09-01T03:00:00.000Z","path":"wiki/机器学习笔记/","text":"What is ML? In short, ML is to Look for a function and to obtain an answer to a certain question, applied in speech recognition, image recognition. Different types of ML Regression: output a scalar. Classification: given classes, output correct one. E.g. alpha go. Structured learning：create something with a structure. How to find a function? Give a function with unknown paraments, called model. \\[ y = b+wx_1 \\] Symbol \\(x_1\\) is called feature.Symbol \\(w\\) and \\(b\\) represent weight and bias. Define loss from Training Data. Loss is a function of parameters \\(b\\) and \\(w\\). It evaluates how good a set of values is. Paint error surface. Optimization: Gradient Descent for example. The process of finding a function is called training. New model Sometimes linear functions are inaccurate, so we need to use a new model to construct function with parameters. ### From linear model, to piecewise linear model. Use Sigmoid Function to approximately express Hard Sigmoid Function, and add multiple Sigmoid Function to express piecewise linear model. Then we can express function as: \\[ y = b + \\sum_ic_i\\ sigmoid(b_i+\\sum_jw_{ij}x_j) \\] We use vector \\(\\theta\\) to express all the parameters in the function above, then the Loss function can be expressed as \\(L(\\theta)\\). After that, we do the optimization to find the \\(\\theta^*\\) satisfying \\(\\theta^*=arg\\ {min}_{\\theta}\\ L\\) What is the general guide on ML? A general guide It can be described as the picture followed. Large training loss Training loss is large. It may result from: 1. Model bias It means that the model is too simple. Solution: redesign more features or deep learning 2. Optimization issue How to know whether optimization causes a large training loss? Start from shallower networks (or other models), which are easier to optimize. If deeper networks do not obtain smaller loss on training data, then there is optimization issue. Small training loss, but large testing loss. Testing loss is large. It may result from: #### 1. Overfitting Overfitting occurs when loss is small on training data, but large on testing data. Solutions: a. more training data, or data augmentation; b. Constrained model: model has less flexibility. Bias-complexity trade-off Cross validation: divide training set into training set and validation set. Use validation set to test the loss of the function obtained from training data set. How to split the training set? N-fold cross validation 2.Mismatch Mismatch occurs when your training data and testing data have different distributions.Its difference from overfitting is that more training data can not obtain a better result. How to find a function? Give a function with unknown paraments, called model. \\[ y = b+wx_1 \\] Symbol \\(x_1\\) is called feature.Symbol \\(w\\) and \\(b\\) represent weight and bias. Define loss from Training Data. Loss is a function of parameters \\(b\\) and \\(w\\). It evaluates how good a set of values is. Paint error surface. Optimization: Gradient Descent for example. The process of finding a function is called training. New model Sometimes linear functions are inaccurate, so we need to use a new model to construct function with parameters. ### From linear model, to piecewise linear model. Use Sigmoid Function to approximately express Hard Sigmoid Function, and add multiple Sigmoid Function to express piecewise linear model. Then we can express function as: \\[ y = b + \\sum_ic_i\\ sigmoid(b_i+\\sum_jw_{ij}x_j) \\] We use vector \\(\\theta\\) to express all the parameters in the function above, then the Loss function can be expressed as \\(L(\\theta)\\). After that, we do the optimization to find the \\(\\theta^*\\) satisfying \\(\\theta^*=arg\\ {min}_{\\theta}\\ L\\)","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"机器学习","slug":"knowledge/机器学习","permalink":"https://dsis-scss.github.io/categories/knowledge/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"VSCode 快速上手","date":"2022-08-27T11:23:05.000Z","path":"wiki/vscode/","text":"先善其事必先利其器，使用一款好的编译器对于我们工作学习来说是至关重要的。不论你使用的是 Windows 、Mac OS 还是 Linux，我们都推荐使用 VS code(Visual Studio code) 编辑器。它是微软开发的一款开源跨平台编辑器，几乎在任何系统(甚至网页上)编辑任何语言的代码。得益于其活跃的社区，VS code 拥有非常丰富的插件，这些插件也使得我们编码体验变得更加友好。 安装 进入官网下载 点击下载 User 的 64 bit 版本。 后序安装中，下图中的两个选项都勾选上，这样后面可以直接通过文件夹打开 vs code： 配置 C++ 调试运行 安装 C++ 运行环境 C++ 有很多编辑器，Clang、GNU C++、MSVC等等。我们这里安装 GNU C++，在 Windows 中，直接安装 MinGW（Minimalist GNU on Windows）即可。如果你是 MacOS 用户，可以通过安装 Command Line Toools 来进行配置。 MinGW 推荐到 SourceForge 进行下载, 选择 8.1.0 版本的 x86_64-posix-seh 资源包文件（64位操作系统，启用 C++ 11 多线程特性等）。另外，如果想要使用最新版 GCC-11.2（支持 C++ 20，但对某些机型可能不适配，谨慎使用），可以到这里下载。 下载完成之后，直接拷贝到 G 盘（或其他盘，根据自己情况来调整）根目录下，然后将下图中的路径（g++.exe所在目录路径）复制到剪贴板： 注意，图中的 MinGW 安装在 G 盘，你需要找到你的 MinGW 路径，打开其中的 bin 文件夹，复制其路径即可。 然后，将复制的路径追加到 path 环境变量中，示意图如下： 如果你在上面的过程中遇到了问题，可以参考该链接中提供的方法：https://new.qq.com/omn/20211202/20211202A08CCW00.html 如果你是 win7 用户，同样可以通过百度来找到对应的修改办法，但要特别注意追加环境变量时的逗号分隔符是英文。 配置环境变量是为了在其他地方都可以用到 bin 目录下的 exe 文件（例如 g++.exe）。 你可通过以下方式检验是否安装成功： 如果你测试的结果与上面的不同，说明环境变量配置失败了，需要重新检查一下前面的步骤，如果实在不行，不妨重启一下电脑试试。 配置 VS Code 运行环境 到了最复杂的一步，由于 VS Code 有着庞大的社区，各种各样的插件、配置会让你感觉到眼花缭乱。这里首先教大家如何在 VS Code 中通过命令行终端（Terminal）中编译运行 C++ 代码，然后再配置如何实现单步调试功能。 安装插件 在这一步，你需要用各种插件来丰富你的 VS Code。打开 VS Code，在左侧工具栏中寻找下图样式的按钮（不要在意按钮的顺序，因为图中已经安装了很多别的插件） 然后在搜索框中输入对应的插件名，点击下载按钮即可。 汉化插件 Chinese C/C++ 插件 Code Runner 安装完 Code Runner 之后，我们点击右下角的设置按钮，进入「扩展设置」（或者通过右上角的「文件」-「首选项」-「设置」-「搜索框中输入 Code Runner 进行查找」）。找到下图中的三项设置，勾上对钩。 然后找到下图中的设置项，点进去 settings.json，设置我们运行 C++ 时的编译命令 点击去之后，添加如下设置代码： 123456&#123; &quot;code-runner.executorMap&quot;: &#123; &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &#125;,&#125; 如果你发现点进去之后 VS Code 中已经生成了很多配置文档，不用担心，你只要确保其中有 C 和 C++ 的编译命令即可。 这里简单解释一下 cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt：$dir 表示当前文件的所在目录，cd 会将终端的工作目录切换到 $dir 下，然后对当前文件 $fileName 使用 g++ 进行编译，编译生成的文件名是 $fileNameWithoutExt，然后紧接着直接通过命令 $dir$fileNameWithoutExt运行编译好的文件。如果你不能完全理解我在说什么也没有关系，只要确保有这一条配置就可以了。 测试运行 接下来我们测试运行 C++ 代码，首先我们需要在电脑中找一个地方创建一个空的文件夹用来存放代码（最好是空的），点击左上角的「文件」，然后点击「打开文件夹」，选择刚刚创建的文件夹。 例如，我这里创建了一个名字为 CPP 的文件夹，点击按钮创建新的文件 a.cpp。 输入以下代码： 1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; return 0;&#125; 点击 Run Code 运行（或者 Ctrl + Alt + N），可以看到下面的终端输出了 Hello World!11 ，运行成功！ 到此为止，你可以通过 VS Code 来写单文件的 CPP 代码了。（如果要是多文件的 CPP 项目，建议使用 MakeFile 来编译） 调试运行 如果你不满足于终端运行，想要单步调试代码，该如何处理？ 也很简单，首先，你在 CPP 文件夹中创建一个名字为 .vscode 的文件，注意前面的点不可以被忽略，它将被 VS Code 视作配置文件。然后在里面创建两个文件： launch.json 注意下面的第 15 行配置，它对应的是你 MinGW 的安装环境，需要找到 bin 目录下的 gdb.exe 文件。注意所有的文件分隔符都是用 / 而不是 \\，如果使用 \\ 还需要将其转义为 \\\\。 1234567891011121314151617181920212223242526&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, // 调试目标文件 &quot;args&quot;: [], // 指定调试传入参数，可自行修改 &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;cwd&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;G:/Program Files/mingw64/bin/gdb.exe&quot;, // /path/to/gdb &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;build-g++&quot; // 每次调试前 - 都进行生成任务执行编译，保证调试的目标文件是最新的 &#125; ] &#125; 注意到启动调试 （launch）之前，我们配置了 build-g++，所以还需要一个 tasks.json文件。 tasks.json 以下内容不需要修改，直接复制粘贴即可。 12345678910111213141516171819202122232425262728293031323334353637383940&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build-g++&quot;, // 给当前的生成任务一个名字 &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ // 如果你以后对于编译参数有任何修改，就在这里修改。 &quot;-g&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasename&#125;&quot;, // $&#123;fileBasenmae&#125; VS Code 内置变量: 当前活动文件的完整文件名 - helloworld.cpp &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, // $&#123;fileBasenameNoExtension&#125; 这个是 VS Code 内置变量: 当前活动文件的完整文件名舍去扩展名 - helloworld &quot;-Wall&quot; // 开启全部警告 ], // 错误消息获得 - 正则表达式 &quot;problemMatcher&quot;: &#123; &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [ &quot;relative&quot;, // &quot;$&#123;workspaceRoot&#125;&quot; &quot;\\\\&quot; ], &quot;pattern&quot;: &#123; &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 &#125; &#125;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, // 指定当前任务类型 &quot;isDefault&quot;: true // 设置为默认任务 &#125; &#125; ] &#125; 配置完成后，你的文件结构应该是这样的（注意 a.cpp 在 CPP 中，而不是在 .vscode 中）： 为了测试方便， 我们写了下面这份代码演示调试流程，代码含义是计算 1~ 10 的和： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int sum = 0; for(int i = 1; i &lt;= 10; i++) &#123; sum += i; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 想要在调试过程中在某条语句处停下，你需要在对应的行前面打上断点，不打断点的话，调试和直接运行并没有明显差异： 然后按 F5，或者点击右上角的三角形选择调试，进入调试。 调试过程中，你可以按 F10 来逐步执行代码，并监控每个变量的值。 如下图所示，我们运行到了 i = 6 这一步，第 7 行代码高亮，这表示 sum += i 还没有执行，这时 sum 只累加了 1 ~ 5，所以 sum = 15。 到此为止，你可以畅快的使用 VS Code 来编写 C++ 代码了！ 其他 插件 Material Icon Theme 该插件可以美化图标，让你的代码项目结构更加清晰。 Community Material Theme 主题美化插件 indent-rainbow 缩进高亮显示，代码结构更加清晰 Bracket Pair Colorizer 2 彩虹括号 详细配置教程：https://blog.csdn.net/hazelnut_x/article/details/108910971 Python VS Code 也可以用来编写 Python，它的配置方法可以参考这里：Python in VS Code 除了编写基本的python，你也可以通过安装 jupyter 插件来方便的编写 ipynb 文件。Python + Jupyter Go VS Code for Go","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"}]},{"title":"Anaconda&Jupyter快速上手","date":"2022-08-10T13:20:39.000Z","path":"wiki/Anaconda-jupyter快速上手/","text":"conda是一个python虚拟环境管理软件，它允许你为每一个python项目创建独立的环境，如果你被python的环境问题折磨过，那么你就会知道conda有多好用。而Anaconda则是python的一个发行版本，也是conda的图形化版本。有了Anaconda，每次在运行一个新的python项目时，你都应该重新创建一个python env，并且在该env下安装python包、执行命令 安装Anaconda(conda) 推荐清华源下载最新的版本，或者合适的版本，注意选择合适你的操作系统和处理器架构的安装包。如果是在没有图形界面的服务器上，推荐安装Miniconda Anaconda的安装有图形化界面，在此就不再赘述，没有特殊要求的话，使用默认配置一路点继续就可以了，需要注意的是，在安装过程中记得勾选将conda配置进系统环境变量中 Miniconda安装包下载下来之后是一个.sh脚本文件，对其添加执行文件后，直接利用bash执行然后按照步骤安装即可 123wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda-x.x.x-Linux-x86_64.shsudo +x Miniconda-x.x.x-Linux-x86_64.sh./Miniconda-x.x.x-Linux-x86_64.sh 注意Miniconda安装时它会询问你是否要运行conda init，请选择yes，此步的作用是将conda的配置写入你的shell配置文件中，安装完成后，可以查看你的shell配置文件是否包含 1234567891011121314# &gt;&gt;&gt; conda initialize &gt;&gt;&gt;# !! Contents within this block are managed by &#x27;conda init&#x27; !!__conda_setup=&quot;$(&#x27;/Users/xingguangjie/opt/anaconda3/bin/conda&#x27; &#x27;shell.zsh&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;if [ $? -eq 0 ]; then eval &quot;$__conda_setup&quot;else if [ -f &quot;/Users/xingguangjie/opt/anaconda3/etc/profile.d/conda.sh&quot; ]; then . &quot;/Users/xingguangjie/opt/anaconda3/etc/profile.d/conda.sh&quot; else export PATH=&quot;/Users/xingguangjie/opt/anaconda3/bin:$PATH&quot; fifiunset __conda_setup# &lt;&lt;&lt; conda initialize &lt;&lt;&lt; 如果没有的话，就无法正常执行conda指令，请重新安装或者切换到conda的安装目录中（执行安装脚本的时候有写），手动执行conda init 1./conda init 完成安装后，在终端中输入conda --versin可正常运行即可（Windows可以在开始-应用程序中找到anaconda prompt作为终端使用） conda常用命令 有了Anaconda，就可以在Anaconda Navigator里面创建虚拟环境、安装包等等，但是不推荐使用，更加常见的方式还是直接通过命令行与conda交互，下面列举几条常见的命令 激活一个环境（切换到已有的环境中） 1conda activate base # 切换到名字为base的环境下（刚刚安装好conda没有创建新环境的情况下默认只有base环境） 从环境中退出 1conda deactivate 创建一个新环境，并且指定环境的python版本 1conda create -n test python=3.7 # 创建python版本为3.7的名为test的环境 删除一个环境 1conda remove test # 删除一个名为test的环境 在特定的环境中安装包 123conda activate testpip install numpy&gt;=3.7 # 通过pip安装版本号高于3.7的numpy包conda install numpy&gt;=3.7 # 通过conda安装版本号高于3.7的numpy包 配置Jupyter jupyter是一个开源的python交互式web应用，最大的用处就是可以一行一行运行python代码，并且实时的将一些数据或者图表打印出来，有助于debug以及数据分析 首先安装jupyter 12conda activate testconda install jupyter # 在名为test的环境下安装jupyter 推荐使用conda安装，它会帮你把所有的依赖都安装好 安装完成后，即可在安装的环境下直接运行jupyter-notebook命令，会自动打开一个浏览器窗口，同时在终端中出现一个本地url，访问这个url即可进入jupyter服务 jupyter中的基本单元是代码块，代码都是一块一块执行的，在代码块中编写代码，然后按shift-Enter即可完成执行这一块的代码，并且产生输出 在服务器中使用jupyter 如果使用云端服务器，则可以配置服务器端口转发实现本地运行服务器端jupyter服务（例如服务器端有完善的python环境或者需要使用服务器GPU运行调试某些python代码） 配置比较简单，可以参考 Jupyter notebook远程连接服务器 Jupyter Notebook服务器配置","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"}]},{"title":"文献管理工具-Zotero","date":"2022-08-10T01:15:57.000Z","path":"wiki/文献管理工具-Zotero/","text":"Zotero介绍 官方网站：Zotero | Your personal research assistant Zotero是一个免费软件，可以帮助你进行文献的收集、整理、注释和引用。 Zotero具有较高的自由度，有许多插件可供选择。 下载与安装 本体 可在Zotero官网下载安装包 运行安装包，选择安装位置即可 浏览器插件-Zotero Connector Zotero Connector可以从网页中抓取文献和元数据，将其保存到本地。只有Zotero运行时Zotero Connector才能使用。 Zotero Connector支持Edge、Chrome、火狐、Safari浏览器 Zotero Connector下载链接 Edge、Chrome插件可在对应浏览器的插件引用市场获取 火狐、Safari的插件安装方法可参考下载页面 插件 打开【Zotero】 点击【工具】—【插件】 将需要安装的插件【拖动】至该页面 安装完毕后重启【Zotero】 推荐插件 ZotFile：自动修改附件名、添加附件 官方网站：ZotFile - Advanced PDF management for Zotero Github仓库：jlegewie/zotfile: Zotero plugin to manage your attachments 茉莉花：抓取中文网站元数据 GIthub仓库：l0o0/jasminum: A Zotero add-on to retrive CNKI meta data 配置 在线同步 打开【Zotero】—【编辑】—【首选项】—【同步】 在【数据同步】栏创建并登录Zotero账号 在【文件同步】栏，可以使用Zotero文件同步服务的300MB免费空间，也可以使用支持WebDAV的云盘，这里使用坚果云为例，坚果云免费账号每月提供1GB上传流量和3GB下载流量，足够用于文献同步 进入坚果云官网，创建并登陆账号，进入【账户信息】—【安全选项】 点击添加应用，输入名称（如Zotero），点击生成密码 将服务器地址、账户、密码复制入【Zotero】设置界面的【文件同步】栏 PDF下载-sci-hub 打开【Zotero】—【编辑】—【首选项】—【高级】—【常规】—【设置编辑器】 接受风险，搜索找到【extensions.zotero.findPDFs.resolvers】 双击编辑，将默认的[]替换为 123456789&#123; &quot;name&quot;:&quot;Sci-Hub&quot;, &quot;method&quot;:&quot;GET&quot;, &quot;url&quot;:&quot;https://sci-hub.hkvisa.net/&#123;doi&#125;&quot;, &quot;mode&quot;:&quot;html&quot;, &quot;selector&quot;:&quot;#pdf&quot;, &quot;attribute&quot;:&quot;src&quot;, &quot;automatic&quot;:true &#125; 其中【https://sci-hub.hkvisa.net】为可用的sci-hub链接 设置完成后可通过ISBN、DOI等下载PDF 也可以在Zotero Connector无法抓取PDF时，右键点击条目手动下载PDF ZotFile 进入【Zotero】—【工具】—【ZotFile Preferences…】 【General Settings】设置更加方便的向条目中添加附件，但个人感觉实用性不强，设置可参考文末的参考链接Zotero：科研小白的第一款文献管理软件 - 知乎 (zhihu.com) 【Tablet Settings】设置与云盘的同步，并实现跨平台同步，设置方法同样参考文末链接Zotero：科研小白的第一款文献管理软件 - 知乎 (zhihu.com) 【Renaming Rules】设置通过规则语句对PDF、DOC等文件进行重命名，规则语句的编写格式参考ZotFile的说明 【Advanced Settings】对重命名进行进阶设置，可以不动 茉莉花 还没用过，待补充 使用实例 在网页中找到需要的文献，点击【Zotero Connector】，可在弹出的页面将本文献的条目归档至某文件夹，并添加tag。这里将文献归档至【TEST】文件夹并添加tag【00】代表未读 可以看到我们刚刚添加的文献，两个文件分别是文献的PDF和网页快照，双击即可打开，此外可在右侧设置文献条目的信息 在阅读文献的过程中做的笔记以及其他相关资料，可以以【附件】的形式添加到文献条目中 左下角的展示的是文献的tag，可以通过指派颜色管理常用的tag，如已读、未读等，右键点击代表已读的tag【Read】，选择指派颜色，即可将其设置为蓝色，快捷键设为【2】，之后就可以通过键盘【2】快速更改条目的阅读状态 参考链接 Zotero | Your personal research assistant Zotero：科研小白的第一款文献管理软件 - 知乎 (zhihu.com) 坚果云官网|网盘|云盘|云服务|团队协作软件|同步盘 (jianguoyun.com) ZotFile - Advanced PDF management for Zotero l0o0/jasminum: A Zotero add-on to retrive CNKI meta data. 一个简单的Zotero 插件，用于识别中文元数据 (github.com)","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"},{"name":"科研软件","slug":"tools/科研软件","permalink":"https://dsis-scss.github.io/categories/tools/%E7%A7%91%E7%A0%94%E8%BD%AF%E4%BB%B6/"}]},{"title":"时序预测论文整理","date":"2022-07-28T08:39:34.000Z","path":"wiki/时序预测论文整理/","text":"Tittle Algorithm Idea classical methods An adaptive prediction approach based on workload pattern discrimination in the cloud An adaptive approach categorizes the workloads into different classes which are automatically assigned for different models according to workload features TODO Exponential Smoothing(ES) A Hierarchical Framework for Modeling and Forecasting Web Server Workload Auto Regression(AR) A linear combination of past values of the variable under consideration is used to forecast the value for upcoming time instances. Dual time-scale distributed capacity allocation and load redirect algorithms for cloud systems Moving Average(MA) non-linear optimization The model is appropriate for time series exhbiting seasonal behavior only Efficient autoscaling in the cloud using predictive models for workload forecasting Autoregressive Integrated Moving Average(ARIMA) also discussed the challenges involved in auto scaling in a cloud environment Workload Prediction Using ARIMA Model and Its Impact on Cloud Applications’ QoS Autoregressive Integrated Moving Average(ARIMA) ARIMA on different confidence interval to predict web server workload Workload characterization and prediction in the cloud: A multiple time series approach Hidden Markov Model distinguish the temporal correlations in obtained clusters of VMs A workload analysis of live event broadcast service in cloud Regression techniques the approach is based on simple statistical models that might not capture the patterns in more complex data Workload characterization and prediction in the cloud: A multiple time series approach multiple time series approch The model does a grouping of similar applications's need in order to improve the accuracy of predictions machine learning methods Support vector machines experts for time series forecasting Self organizing map(SOM) and support vector machines(SVMs) Self organizing map was used to cluster the data in different regions while SVMs were used to predict the future data Referential kNN Regression for Financial Time Series Forecasting \\(k\\) Nearest Neighbors(kNN) For financial time series prediction. kNNs are lazy learners and need high computational cost Hierarchical neural networks based prediction and control of dynamic reconfiguration for multilevel embedded systems the Neural network used to model workload variations in multimidia designs A cost-aware auto-scaling approach using the workload prediction in service clouds Linear regression the predicted workload was used to decide the type of scaling Efficient resources provisioning based on load forecasting in cloud Support Vector Regression(SVR) and Kalman smoother It achieved high prediction accuracy Combining time series prediction models using genetic algorithm to autoscaling Web applications hosted in the cloud infrastructure Ensemble based model It uses five different base prediction models. Each model is assigned a weight and contributes accordingly in predictions. The weight are assigned and optimized using genetic algorithm Empirical prediction models for adaptive resource provisioning in the cloud Neural network and Linear regression RVLBPNN: A Workload Forecasting Model for Smart Cloud Computing back propagation learning algorithm It adjusts the weights of model according to error trend. A Predictive Method for Workload Forecasting in the Cloud Environment neural network and steepest descent learning algorithm suffers from high prediction errors. Workload prediction in cloud using artificial neural network and adaptive differential evolution neural network and adaptive differential evolution","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"论文","slug":"knowledge/论文","permalink":"https://dsis-scss.github.io/categories/knowledge/%E8%AE%BA%E6%96%87/"}]},{"title":"分布式系统入门(MIT 6.824)","date":"2022-07-27T09:02:26.000Z","path":"wiki/分布式系统入门/","text":"MIT6.824课程主页 http://nil.csail.mit.edu/6.824/2022/ 课程安排 http://nil.csail.mit.edu/6.824/2022/schedule.html 论文翻译 MapReduce (2004) GFS (2003) Fault-Tolerant Virtual Machines (2010) Raft (2014) lab参考 SwordHarry/MIT6.824_2021_note 参考书目 DDIA-设计数据密集型应用","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"体系结构(System)","slug":"knowledge/体系结构-System","permalink":"https://dsis-scss.github.io/categories/knowledge/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-System/"}]},{"title":"test工具","date":"2022-07-27T09:02:19.000Z","path":"wiki/test工具/","text":"","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"},{"name":"科研软件","slug":"tools/科研软件","permalink":"https://dsis-scss.github.io/categories/tools/%E7%A7%91%E7%A0%94%E8%BD%AF%E4%BB%B6/"}]},{"title":"DDIA-设计数据密集型应用","date":"2022-07-27T09:01:14.000Z","path":"wiki/DDIA-设计数据密集型应用/","text":"书名 《Designing Data-Intensive Applications》 简介 现今，尤其是在互联网领域，大多数应用都属于数据密集型应用。本书从底层数据结构到顶层架构设计，将数据系统设计中的精髓娓娓道来。其中的宝贵经验无论是对架构师、DBA、还是后端工程师、甚至产品经理都会有帮助。 实验室有一部分研究是在分布式多机系统下的数据存储与管理，特别是应用于云硬盘系统的存储管理，该书可以有助于理解数据密集型应用所需要考虑的问题，发现可以优化的点，以及对于分布式架构有所了解。 中文翻译 设计数据密集型应用 - 中文翻译","categories":[{"name":"资源","slug":"resource","permalink":"https://dsis-scss.github.io/categories/resource/"},{"name":"书目","slug":"resource/书目","permalink":"https://dsis-scss.github.io/categories/resource/%E4%B9%A6%E7%9B%AE/"}]}],"categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"机器学习","slug":"knowledge/机器学习","permalink":"https://dsis-scss.github.io/categories/knowledge/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"},{"name":"科研软件","slug":"tools/科研软件","permalink":"https://dsis-scss.github.io/categories/tools/%E7%A7%91%E7%A0%94%E8%BD%AF%E4%BB%B6/"},{"name":"论文","slug":"knowledge/论文","permalink":"https://dsis-scss.github.io/categories/knowledge/%E8%AE%BA%E6%96%87/"},{"name":"体系结构(System)","slug":"knowledge/体系结构-System","permalink":"https://dsis-scss.github.io/categories/knowledge/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-System/"},{"name":"资源","slug":"resource","permalink":"https://dsis-scss.github.io/categories/resource/"},{"name":"书目","slug":"resource/书目","permalink":"https://dsis-scss.github.io/categories/resource/%E4%B9%A6%E7%9B%AE/"}],"tags":[]}