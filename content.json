{"pages":[{},{},{},{},{},{},{}],"posts":[{"title":"6-S801-EnvInit","date":"2022-09-09T08:47:56.000Z","path":"wiki/6-S801-EnvInit/","text":"Env init install on WSL 12$ sudo apt-get update &amp;&amp; sudo apt-get upgrade$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu Lab: Xv6 and Unix utilities Boot xv6 clone code 1git clone git://g.csail.mit.edu/xv6-labs-2021 checkout to util branch 12cd xv6-labs-2021git checkout util finish lab 完成lab后，可以commit自己的工作： 1git commit -am &#x27;my solution for util lab exercise 1&#x27; run qemu 编译qemu，并运行xv6 1make qemu 我这里遇到了一些编译问题，需要安装一些工具： 1sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 之后可以正常编译。qemu中输入ls 12345678910111213141516171819202122$ ls. 1 1 1024.. 1 1 1024README 2 2 2226xargstest.sh 2 3 93cat 2 4 23896echo 2 5 22728forktest 2 6 13080grep 2 7 27248init 2 8 23824kill 2 9 22696ln 2 10 22648ls 2 11 26128mkdir 2 12 22792rm 2 13 22784sh 2 14 41664stressfs 2 15 23800usertests 2 16 156008grind 2 17 37968wc 2 18 25032zombie 2 19 22192console 3 20 0 ps命令 xv6中没有ps命令，但是可以通过ctrl-p打印每个进程的信息 123$1 sleep init2 sleep sh 退出qemu 通过ctrl-a x推出qemu 参考资料 实验网站 实验仓库地址","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"操作系统","slug":"knowledge/操作系统","permalink":"https://dsis-scss.github.io/categories/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"6.S801-Util_lab","date":"2022-09-07T11:45:41.000Z","path":"wiki/6-S801-Util-lab/","text":"Util_lab sleep 在xv6中实现sleep命令 一些建议： Before you start coding, read Chapter 1 of the xv6 book. Look at some of the other programs in user/ (e.g., user/echo.c, user/grep.c, and user/rm.c) to see how you can obtain the command-line arguments passed to a program. If the user forgets to pass an argument, sleep should print an error message. The command-line argument is passed as a string; you can convert it to an integer using atoi (see user/ulib.c). Use the system call sleep. See kernel/sysproc.c for the xv6 kernel code that implements the sleep system call (look for sys_sleep), user/user.h for the C definition of sleep callable from a user program, and user/usys.S for the assembler code that jumps from user code into the kernel for sleep. Make sure main calls exit() in order to exit your program. Add your sleep program to UPROGS in Makefile; once you've done that, make qemu will compile your program and you'll be able to run it from the xv6 shell. Look at Kernighan and Ritchie's book The C programming language (second edition) (K&amp;R) to learn about C. 我的实现： 思考： 在文件kernel/sysproc.c中，有sys_sleep的实现，即系统调用sleep的实现。 的函数定义为uint_64 sys_sleep(void)因为这个函数只被调用，它的参数由全局变量传递（寄存器）。 sys_sleep()函数有两种返回值，一种是非正常的-1，另一种是正常的0。因此外部调用的函数应该要获得这个值一并返回。 另外在文件user/user.h中，sleep函数定义为int sleep(int)，这个这个定义之所以是两个int，是因为user/ysys.S文件中的sleep为： 12345.global sleep sleep: li a7, SYS_sleep ecall ret 实现： 注意要修改Makefile 123456789101112131415161718192021#include &quot;kernel/types.h&quot; #include &quot;user/user.h&quot; int main(int argc, char *argv[]) &#123; int n; if(argc != 2)&#123; fprintf(2, &quot;Usage: sleep [n secodes]\\n&quot;); exit(1); &#125; // fprintf(2, &quot;sleep %s\\n&quot;, argv[1]); n = atoi(argv[1]); // fprintf(2, &quot;sleep %d\\n&quot;, n); if (0 == sleep(n))&#123; exit(0); &#125; exit(1); &#125; 测试 Note that make grade runs all tests, including the ones for the assignments below. If you want to run the grade tests for one assignment, type: 1$ ./grade-lab-util sleep This will run the grade tests that match \"sleep\". Or, you can type: 1$ make GRADEFLAGS=sleep grade ## pingpong 实现pingpong调用，通过fork创建子进程，通过pipe进行进程间通信。 提示： Use pipe to create a pipe. Use fork to create a child. Use read to read from the pipe, and write to write to the pipe. Use getpid to find the process ID of the calling process. Add the program to UPROGS in Makefile. User programs on xv6 have a limited set of library functions available to them. You can see the list in user/user.h; the source (other than for system calls) is in user/ulib.c, user/printf.c, and user/umalloc.c. 我的实现： 思考 关于pipe pipe的入参是一个整数数组，pipe函数结束后，表示两个文件描述符。如： 12int p[2];pipe(p); 其中pipe返回的管道p[0]用于读，p[1]用于写。任何进程如果获取这个pipe的文件描述符就可以从管道中读取或写入，但是信息只能被读取一次。程序的运行会被对文件的读取阻塞。 关于fork fork后，文件的描述符在两个进程中都是存在的。因此父进程和子进程都获得同一个pipe，都可以向pipe中写入或读取数据。 实现 实现的过程中，强化了pingpong的信息来源于另一个进程，验证程序确实是从另一个进程获取的打印信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[])&#123;int p[2];int pid, len = 0;char msg[1];if(argc != 1)&#123; fprintf(2, &quot;Usage: pingpong\\n&quot;); exit(1);&#125; pipe(p); if(fork() == 0) &#123; //child close(0); pid = getpid(); len = read(p[0], msg, sizeof(msg)); if(1 != len) exit(1); fprintf(1, &quot;%d: received p%cng\\n&quot;,pid,msg[0]); msg[0] = &#x27;o&#x27;; len = write(p[1], msg, sizeof(msg)); if(1 != len) exit(1); close(p[0]); close(p[1]); exit(0); &#125; else &#123; //parent close(0); pid = getpid(); msg[0] = &#x27;i&#x27;; len = write(p[1], msg, sizeof(msg)); if(1 != len) exit(1); len = read(p[0], msg, sizeof(msg)); if(1 != len) exit(1); fprintf(1, &quot;%d: received p%cng\\n&quot;,pid,msg[0]); close(p[0]); close(p[1]); exit(0); &#125;&#125; 测试 通过运行命令进行测试 1./grade-lab-util pingpong primes Your goal is to use pipe and fork to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35. 提示： Be careful to close file descriptors that a process doesn't need, because otherwise your program will run xv6 out of resources before the first process reaches 35. Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited. Hint: read returns zero when the write-side of a pipe is closed. It's simplest to directly write 32-bit (4-byte) ints to the pipes, rather than using formatted ASCII I/O. You should create the processes in the pipeline only as they are needed. Add the program to UPROGS in Makefile. 思考 子进程不需要管道的输入，同时为了减少管道的文件数量。可以将自己的默认打开的管道0[stdin]关闭。 如何实现： 使用pipe构建能与子进程沟通的管道write_fd 使用fork创建子进程，子进程中关闭文件0，同时复制write_fd[0]，再关闭write_fd[0]，可以从文件0读取从父进程获取的数据。 另外子进程中可以关闭write_fd[1]，因为子进程不用向父进程传递信息。 最开始的父进程将2-35写入write_fd 对每个子进程，如果没有输出过质数，则判断是否为质数，是则输出，且再创建一个子进程。 如果子进程已经输出过质数，则自己也有子进程，则将获得的输入传递给自己的子进程。 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int is_prime(int x)&#123; int i = 2; if(x == 1) return 0; if(x &lt;= 3) return 1; for(i = 2; i * i &lt;= x; i++) &#123; if(0 == x%i) return 0; &#125; return 1;&#125;intmain(int argc, char *argv[])&#123; // int read_fd[2]; int write_fd[2]; // for root process, only write int i,first = 1;; if(argc != 1)&#123; fprintf(2, &quot;Usage: primes\\n&quot;); exit(1); &#125; // pipe(read_fd); pipe(write_fd); if(0 == fork()) &#123; // child first = 1; close(0); dup(write_fd[0]); close(write_fd[0]);// read 0 is read from father process&#x27;s 1 close(write_fd[1]);// close father process&#x27;s 1 while(read(0,&amp;i,sizeof(int)) == sizeof(int)) &#123; if(first &amp;&amp; is_prime(i)) &#123; first = 0; fprintf(1,&quot;prime %d\\n&quot;,i); // print to stdout pipe(write_fd); // make a pipe to send number to next child if(0 == fork()) &#123; first = 1; close(0); dup(write_fd[0]); close(write_fd[0]);// read 0 is read from father process&#x27;s 1 close(write_fd[1]);// close father process&#x27;s 1 &#125; else &#123; close(1); dup(write_fd[1]); close(write_fd[1]); // write to 1 is write to child process // if close 1, child ends &#125; &#125; else if (!first)&#123; write(1,&amp;i,sizeof(int)); // write to child &#125; &#125; close(1);// close 1 to end child wait(0);//wait child exit(), guarantee order. For last child, just end. exit(0); &#125; else &#123; // parent close(write_fd[0]); for(i = 2; i &lt;=35; i++) &#123; write(write_fd[1], &amp;i, sizeof(int)); &#125; close(write_fd[1]); wait(0); &#125; exit(0);&#125; 测试 通过运行命令进行测试 1./grade-lab-util primes find Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c. 提示： Look at user/ls.c to see how to read directories. Use recursion to allow find to descend into sub-directories. Don't recurse into \".\" and \"..\". Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.//在QEMU的各个运行期间能持久化之前的文件处理，因此需要重新make以获得清空的目录树 You'll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5. Note that == does not compare strings like in Python. Use strcmp() instead. Add the program to UPROGS in Makefile. 思考 find 需要两个用户参数，分别是[dir]和[file name]，因此我们需要设置错误提示 阅读user/ls.c，查看如何打开一个文件或目录 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// find.c#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;static char *_fmtname(char *path)&#123; static char buf[DIRSIZ + 1]; char *p; // Find first character after last slash. for (p = path + strlen(path); p &gt;= path &amp;&amp; *p != &#x27;/&#x27;; p--) ; p++; // Return blank-padded name. if (strlen(p) &gt;= DIRSIZ) return p; memmove(buf, p, strlen(p)); memset(buf + strlen(p), &#x27;\\0&#x27;, DIRSIZ - strlen(p)); return buf;&#125;void find(char *path, char *filename)&#123; char buf[512], *p; int fd; struct dirent de; struct stat st; if ((fd = open(path, 0)) &lt; 0) &#123; fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; &#125; if (fstat(fd, &amp;st) &lt; 0) &#123; fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); close(fd); return; &#125; switch (st.type) &#123; case T_FILE: if (strcmp(_fmtname(path), filename) == 0) &#123; printf(&quot;%s\\n&quot;, path); &#125; break; case T_DIR: if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) &#123; printf(&quot;find: path too long\\n&quot;); break; &#125; strcpy(buf, path); p = buf + strlen(buf); *p++ = &#x27;/&#x27;; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) &#123; if (de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if (stat(buf, &amp;st) &lt; 0) &#123; printf(&quot;find: cannot stat %s\\n&quot;, buf); continue; &#125; switch (st.type) &#123; case T_FILE: if (strcmp(_fmtname(buf), filename) == 0) &#123; printf(&quot;%s\\n&quot;, buf); &#125; break; case T_DIR: if (strcmp(&quot;.&quot;, _fmtname(buf)) == 0 || strcmp(&quot;..&quot;, _fmtname(buf)) == 0) &#123; break; &#125; find(buf, filename); break; &#125; &#125; break; &#125; close(fd);&#125;int main(int argc, char *argv[])&#123; if (argc != 3) &#123; fprintf(2, &quot;Usage: find [dir] [file_name]\\n&quot;); exit(1); &#125; find(argv[1], argv[2]); exit(0);&#125; 测试 1./grade-lab-util find xargs Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c. xargs命令将左边管道的输出，每一行作为参数传递给xargs的参数种的命令并执行： 1234567$ echo hello too | xargs echo byebye hello too$$ echo &quot;1\\n2&quot; | xargs -n 1 echo lineline 1line 2$ 提示 Use fork and exec to invoke the command on each line of input. Use wait in the parent to wait for the child to complete the command. To read individual lines of input, read a character at a time until a newline ('') appears. kernel/param.h declares MAXARG, which may be useful if you need to declare an argv array. Add the program to UPROGS in Makefile. Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu. 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &quot;kernel/types.h&quot;#include &quot;kernel/param.h&quot;#include &quot;user/user.h&quot;#define BUFFER_SIZE 512intmain(int argc, char *argv[])&#123; // for xarg it&#x27;s output is stdout, and it&#x27;s input is xargs&#x27;s left pipe(also stdin) char buffer[BUFFER_SIZE]; char * offset = buffer; char *xargs_argv[MAXARG]; int xargs_argc; int basic_xargs_argc = argc - 1; int ret = 1; int i; if(argc == 1) &#123; xargs_argv[0] = &quot;echo&quot;; basic_xargs_argc = 1; &#125; else &#123; for(i = 1; i &lt; argc; i ++) &#123; xargs_argv[i-1] = argv[i]; &#125; &#125; while(1) &#123; xargs_argc = basic_xargs_argc; offset = buffer; *offset = 0; do &#123; ret = read(0,offset,sizeof(char)); &#125;while(offset &lt; buffer+BUFFER_SIZE &amp;&amp; *(offset) !=&#x27;\\n&#x27; &amp;&amp; ret &amp;&amp; (offset++||1)); *offset = 0; if(ret) &#123; xargs_argv[xargs_argc++] = buffer; xargs_argv[xargs_argc] = 0; if(0 == fork()) &#123;//child // for(i = 0; i &lt; MAXARG &amp;&amp; xargs_argv[i] !=0; i++) // &#123; // printf(&quot;xargv[%d]: %s\\n&quot;,i, xargs_argv[i]); // &#125; exec(xargs_argv[0],xargs_argv); exit(0); &#125; else&#123; wait(0); &#125; &#125; else &#123; exit(0); &#125; &#125; exit(0);&#125; 测试 1./grade-lab-util xargs 参考资料 实验网站 实验仓库地址","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"操作系统","slug":"knowledge/操作系统","permalink":"https://dsis-scss.github.io/categories/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"版本控制系统——git","date":"2022-09-02T12:50:05.000Z","path":"wiki/git/","text":"本页面将着重介绍 Git 这一版本控制系统，与 GitHub 相关的内容，请参考 GitHub 帮助 Git 是目前使用最广泛的版本控制系统之一。OI Wiki 也使用了 Git 作为版本控制系统。 安装 Windows 使用安装向导安装 本节以 Git for Windows 2.28.0（2020-07-27 更新）为例。安装页面的选项可能会随着时间而变动。 Windows 系统可以在 Git 官网 获取到 Git for Windows（下文简称 Git）的安装包。 下载完成后，运行 Git 的安装程序。弹出的页面如下图所示。 点击 Next &gt;，选择安装路径。 点击 Next &gt;，选择安装可选项。 默认的选项如上图所示，均不建议取消勾选。其他未勾选的选项可以依照需求勾选。 ??? note \"各选项功能详解\" 默认勾选的选项： - `Windows Explorer integration`：资源管理器集成（右键菜单）。 - `Git Bash Here`：在当前目录运行 Git 命令行。 - `Git GUI Here`：在当前目录运行 Git 图形化页面。 - `Git LFS`：安装 Git Large File Support（大文件支持）。[^note1] - `Associate .git* configuration files with the default text editor`：将所有 `.git` 配置文件与默认文本编辑器关联，并用其打开。默认文本编辑器会在后面配置。 - `Associate .sh files to be run with Bash`：将所有扩展名为 `.sh` 的文件与 Git Bash 关联，并用其执行。 * * * 默认不勾选的选项： - `Additional icons` - `On the Desktop`：让 Git 在桌面创建快捷方式。 - `Use a TrueType font in all console windows`：让 Git 在所有命令行（包括 cmd 命令行窗口）中都使用 TrueType 字体。 - `Check daily for Git for Windows updates`：让 Git 每天检查更新。 点击 Next &gt;，选择存放 Git 快捷方式的开始菜单文件夹。若勾选 Don't create a Start Menu folder，则 Git 不会在开始菜单创建快捷方式。 点击 Next &gt;，选择默认的编辑器。 在下拉菜单栏中，Git 提供了 nano、Vim、Notepad++、Visual Studio Code、Visual Studio Code Insiders（VS Code 预览版）、Sublime Text、Atom 和 VSCodium 作为默认编辑器的预设方案。如果系统已经安装了上述的一种或多种编辑器，可以直接选择其中一种并进入下一步。另外，还可通过 Select other editor as Git's default editor 项手动指定默认编辑器。 除了 Vim 外，如果选择了尚未安装的编辑器，安装程序会阻止使用者进入下一步。1用户可以通过给出的官网链接跳转到下载页面，完成编辑器的安装后继续安装 Git。 选好默认编辑器后，点击 Next &gt; 进入下一步。 接下来的每一步都直接点击 Next &gt;。当 Next &gt; 变为 Install 时，按下 Install 进行安装。 最后，该页面出现，Git 安装完成。此时可以取消勾选 View Release Notes，然后按下 Next &gt; 直接退出；也可以直接按下 Next &gt; 查看版本更新信息；亦可以勾选 Launch Git Bash 运行 Git 命令行。 使用包管理器安装 在 scoop 或 winget 可用的情况下，Git for Windows 可以使用以下命令安装： 123scoop install git#或者winget install Git.Git 这种安装方式的好处是安装过程由系统接管，相对安装向导而言更为方便。需要注意的是，这种方式默认编辑器为 vim。 Linux Linux 系统可以通过包管理器进行安装。不同 Linux 发行版的安装方式可能不同，Git 官网 给出了不同系统下的安装方式。 macOS macOS 系统只需在终端执行 brew install git 命令即可安装。（需安装 Homebrew） 配置 Git 根据配置文件的应用范围，将配置文件分为不同的等级，其中较常用的有两个级别2： 适用于当前用户的全局配置文件，该用户操作本系统上的所有仓库时都会查询该配置文件。 适用于当前仓库的配置文件。 当多个配置文件对同一个选项作出设置的时候，局部设置会自动覆盖全局设置。因此如果需要在某个仓库应用特定的设置的话，只需更改该仓库下的特定设置即可，不会对全局设置造成影响。 修改配置文件需要用到 git config 命令。 设置用户信息 安装 Git 后，第一件事情就是设置你的用户名和邮箱。这些信息在每次提交时都会用到。 12$ git config --global user.name &quot;OI Wiki&quot;$ git config --global user.email oi-wiki@example.com ???+note 这里给出的用户名和邮箱仅供演示。您在根据本页面的内容配置时，请记得将这里的用户名和邮箱改成自己的信息。 这里的 --global 表示修改的是全局配置，即该设置对当前用户下的所有仓库均有效。如果不添加 --global 选项，则会默认修改当前仓库下的配置文件。 如果想要修改某个仓库的特定设置，只需在该仓库下执行不带 --global 的命令即可。 配置编辑器 1$ git config --global core.editor emacs 执行如上命令可以将编辑器更改为 Emacs。 在 Windows 下，Git 的默认编辑器可以在安装 Git 时选择（见前文）。之后若要修改，在 Git Bash 里输入如上命令，将编辑器名换成编辑器的绝对路径，运行命令即可。 显示配置 可以通过 git config -l 列出当前已经设置的所有配置参数。使用 git config --global -l 可以列出所有全局配置。 仓库操作基础 新建 Git 仓库 新建一个 Git 仓库非常简单，只需在想要建立仓库的文件夹输入如下命令： 1$ git init Git 将在当前文件夹新建一个 .git 文件夹，一个仓库就这样建好了。 如果想把一个仓库克隆到自己的电脑上（比如将 OI Wiki 的代码拷贝到本地上进行编辑），采用 git clone 命令即可。 1$ git clone https://github.com/OI-wiki/OI-wiki ???+note \"远程仓库的链接\" 这里给出的仓库链接是 HTTP(S) 链接，也即我们采用了 HTTP(S) 方式连接到远程仓库。 事实上，连接到远程仓库的方式还有多种。其中使用 ssh 连接到远程仓库的方法更为方便和安全，在「远程仓库的管理」部分我们会简单介绍使用 ssh 连接到远程仓库的方法。 这样，被克隆的仓库的内容就会被储存到当前文件夹下一个与仓库同名的新文件夹。在本例中，当前文件夹下会出现一个名为 OI-wiki 的新文件夹。 跟踪文件 在对仓库的文件做出了一些更改后，这些更改需要被纳入到版本管理当中去。 使用 git status 命令可以查看当前仓库文件的状态。 举个例子，在一个空仓库中新增了一个 README.md 文件后，执行 git status 命令的效果如下： 1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) README.mdnothing added to commit but untracked files present (use &quot;git add&quot; to track) 这里的 Untracked files 指的是 Git 之前没有纳入版本跟踪的文件。如果文件没有纳入版本跟踪，对该文件的更改不会被 Git 记录。 执行 git add &lt;文件&gt; 命令可以将指定的文件纳入到版本跟踪中。 12345678910$ git add README.md # 将这个文件纳入到版本跟踪中$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: README.md 这时 README.md 已经纳入了版本跟踪，放入了暂存区。接下来只需执行 git commit 命令就可以提交这次更改了。 但在进行这一工作之前，让我们先对 README.md 做点小更改。 12345678910111213141516$ vim README.md # 随便更改点东西$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: README.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore -- &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md 你会发现 README.md 同时处于暂存区和非暂存区。实际上，是否处于暂存区是对于更改而言的，而不是对于文件而言的，所以对 README.md 的前一次更改已被纳入暂存区，而后一次更改还没有。如果这时候执行 git commit 命令，只有处于暂存区的更改会被提交，而非暂存区的更改，则不会被提交。 Git 给了一条提示，执行 git add README.md 就可以将非暂存区的更改放入暂存区了。 ???+note \"一次性将所有更改放入暂存区\" git add 命令会将对指定的文件的更改放入暂存区中。 在多数情况下，用户更期望一次性将所有更改都放入暂存区中，这时候可以应用 `git add -A` 命令。该命令会将所有更改（包括未被纳入版本跟踪的文件，不包括被忽略的文件）放入暂存区。 如果只需更新已被纳入版本跟踪的文件，而不将未纳入版本跟踪的文件加入暂存区，可以使用 `git add -u`。 ???+note \"忽略文件\" 有些时候我们并不希望将一些文件（如可执行文件等）纳入到版本跟踪中。这时候可以在仓库根目录下创建 .gitignore 文件，在该文件里写下想要忽略的文件。Git 将不会将这些文件纳入到版本跟踪中。 例如，`*.exe` 将自动忽略仓库里的所有扩展名为 `.exe` 的文件。 现在将非暂存区的文件加入暂存区，将所有更改一并提交（commit）。 12345$ git add README.md$ git commit # 接下来会弹出编辑器页面，你需要写下 commit 信息[master (root-commit) f992763] initial commit 1 file changed, 2 insertions(+) create mode 100644 README.md 现在重点观察一下这一次 commit 的信息。 master 表示当前位于 master 分支（关于分支的问题，下文将会详细介绍），b13c84e 表示本次提交的 SHA-1 校验和的前几位，后面则是本次提交的信息。 需要特别关注的是这里的 SHA-1 校验码，每个校验码都与某个时刻仓库的一个快照相对应。利用这一特性我们可以访问历史某个时刻的仓库快照，并在该快照上进行更改。 接下来两行则详细说明了本次更新涉及的文件更改。 另外，commit 过程中可以利用几个参数来简化提交过程： -a：在提交前将所有已跟踪的文件的更改放入暂存区。需要注意的是未被跟踪的文件（新创建的文件）不会被自动加入暂存区，需要用 git add 命令手动添加。 -m：该参数后跟提交信息，表示以该提交信息提交本次更改。例如 git commit -m \"fix: typo\" 会创建一条标题为 fix: typo 的 commit。 查看提交记录 使用 git log 命令可以查看仓库的提交历史记录。 可以看到，提交历史里记录了每次提交时的 SHA-1 校验和，提交的作者，提交时间和 commit 信息。 123456789101112$ git logcommit ae9dd3768a405b348bc6170c7acb8b6cb5fe333e (HEAD -&gt; master)Author: OI Wiki &lt;oi-wiki@example.com&gt;Date: Sun Sep 13 00:30:18 2020 +0800 feat: update README.mdcommit f99276362a3c260d439364c505a7a06859f34bf9Author: OI Wiki &lt;oi-wiki@example.com&gt;Date: Sun Sep 13 00:06:07 2020 +0800 initial commit 分支管理 为什么版本管理中需要分支管理呢？答案主要有两点： 直接更改主分支不仅会使历史记录混乱，也可能会造成一些危险的后果。 通过分支，我们可以专注于当前的工作。如果我们需要完成两个不同的工作，只需开两个分支即可，两个分支间的工作互不干扰。 在 Git 中，简单来说，分支就是指向某个快照的指针。每次提交时，Git 都会为这次提交创建一个快照，并将当前分支的指针移动到该快照。 另外还有一个 HEAD 指针，它指向当前所在的分支。 切换分支的过程，简单来说就是将 HEAD 指针，从指向当前所在的分支，改为指向另外一个分支。在这一过程中，Git 会自动完成文件的更新，使得切换分支后仓库的状态与目标分支指向的快照一致。 分支的创建 利用 git branch 命令可以创建分支，git switch 命令可以切换分支，git switch -c 命令可以创建分支并切换到这个新分支。 12345$ git switch -c dev # 创建一个叫做 dev 的新分支并切换当前分支到 devSwitched to branch &#x27;dev&#x27;$ git branch # 查看分支列表 master* dev dev 前面的星号代表该仓库的当前分支为 dev，接下来对这个仓库的更改都将记录在这个分支上。 试着创建一个新文件 aplusb.cpp。 123456$ vim aplusb.cpp$ git add aplusb.cpp$ git commit -m &quot;feat: add A+B Problem code&quot;[dev 5da093b] feat: add A+B Problem code 1 file changed, 7 insertions(+) create mode 100644 aplusb.cpp 现在切换回 master 分支，这时候文件夹中没有了 aplusb.cpp，一切都回到了刚刚创建 dev 分支时的状态。这时候可以在 master 分支上继续完成其他的工作。 123456$ git switch masterSwitched to branch &#x27;master&#x27;$ vim README.md # 对 README 做些小改动$ git commit -a -m &quot;feat: update README.md&quot;[master 5ca15f0] feat: update README.md 1 file changed, 1 insertion(+), 1 deletion(-) 下面用一张图来解释刚才的操作过程。 master 分支被标红，表明在这几次操作后，它是当前分支（即 HEAD 指向的位置）。 最开始时 master 指向 ae9dd37 这一快照。 接下来在 master 所在的位置创建了一个新的 dev 分支，该分支一开始和 master 指向相同位置。 在 dev 分支上作了一些更改（创建了 aplusb.cpp），进行了一次提交，本次提交后，dev 分支指向 5da093b 这一快照。 切换回 master 分支后，因为 master 分支还指向 ae9dd37，还没有创建 aplusb.cpp，因此仓库中没有这一文件。 接下来在 master 分支上进行更改（更新了 README.md），进行了一次提交，master 分支指向了 5ca15f0 这一快照。 分支的合并 当一个分支上的工作已经完成，就可以将这些工作合并到另外一个分支上去。 还是接着上面这个例子，dev 分支的工作已经完成，通过 git merge 命令可以将该分支合并到当前分支（master）上： 12345$ git merge devMerge made by the &#x27;recursive&#x27; strategy. aplusb.cpp | 7 +++++++ 1 file changed, 7 insertions(+) create mode 100644 aplusb.cpp 这次合并具体是怎么执行的呢？ 在合并之前，master 指向 5ca15f0，而 dev 指向 5da093b，这两个状态并不在一条链上。 Git 会找到这两个状态的最近公共祖先（在上图中是 ae9dd37），并对这三个快照进行一次合并。三个快照合并的结果作为一个新的快照，并将当前分支指向这一快照。 合并过程本身也是一次提交，不过与常规提交不同的是，合并提交有不止一个前驱提交，它是多个提交状态合并后的结果。 在合并完成后，dev 分支就完成了它的使命，这时候可以利用下面的命令删除 dev 分支： 1$ git branch -d dev # 对于未合并的分支，可以使用 -D 参数强制删除 不过合并过程并非总是这么顺利，在某些情况下，合并过程可能会出现冲突，这个问题接下来会讲到。 解决合并冲突 如果在两个分支中，对同一个文件的同一部分进行了不同的更改，Git 就无法自动合并这两个分支，也就是发生了合并冲突。 接着上面的例子，假如你在合并后的 master 分支的基础上，新开了一个 readme-refactor 分支，准备重写一份自述文件。但因为一些疏忽，你同时更改了 readme-refactor 和 master 分支的自述文件。 刚开始自述文件是这样的： 123# This is a test repo.This repo includes some c++ codes. 在 readme-refactor 分支下的自述文件是这样的： 123# Code LibraryThis repo includes some c++ codes. 在 master 分支下的自述文件是这样的： 123# This is a code library.This repo includes some c++ codes. 这时候运行 git merge readme-refactor 命令，Git 提示出现了合并冲突。 执行一下 git status 命令，可以查看是哪些文件引发了冲突。 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 如何解决冲突？对于每个发生了合并冲突的文件，Git 都会在这些文件中加入标准的冲突解决标记。比如这个例子中的 README.md 文件，打开后它长这个样子： 1234567&lt;&lt;&lt;&lt;&lt;&lt; HEAD# This is a code library.======# Code Library&gt;&gt;&gt;&gt;&gt;&gt; readme-refactorThis repo includes some c++ codes. ====== 作为分界线将两个分支的内容隔开，&lt;&lt;&lt;&lt;&lt;&lt; HEAD 标记和 ====== 之间的部分是 HEAD 指针（master 分支）的内容，而 ====== 和 &gt;&gt;&gt;&gt;&gt;&gt; readme-refactor 标记之间的部分是 readme-refactor 分支的内容。 通过编辑文本来处理冲突，删除这些冲突标记，保存文件，将这些文件纳入暂存区后提交，就可以解决合并冲突了。 123$ git add README.md # 将发生冲突的文件纳入暂存区$ git commit[master fe92c6b] Merge branch readme-refactor into master 其他合并方式 默认情况下，Git 采用 Merge（合并）的方式合并两个分支。使用该方法将分支 B 并入分支 A 时，会将 B 分支的所有 commit 并入 A 分支的提交历史中。 除此以外，Git 还提供了两种合并分支的方式：Squash（压缩）和 Rebase（变基）。 Squash（压缩） 使用 Squash 方式将分支 B 并入分支 A 时，在 B 分支上的所有更改会被合并为一次 commit 提交到 A 分支。 在 git merge 中加入 --squash 参数即可使用 Squash 方式进行分支合并。 1git merge &lt;branch&gt; --squash 需要注意的是，在执行上述命令后，Git 只会将 B 分支的所有更改存入 A 分支的缓冲区内，接下来还需要执行一次 git commit 命令完成合并工作。 使用 Squash 方式合并可以简化 commit 记录，但是会丢失具体到每一次 commit 的信息（每次 commit 的提交者，每次 commit 的更改等等），只留下合并为一个整体的信息（每次 commit 的提交者会以 \"Co-authored-by\" 的形式在提交信息中列出）。但如果是在 GitHub 上进行 Squash and Merge，原有的信息都可以在 Pull Request 中查看。 Rebase（变基） 使用 Rebase 方式将分支 B 并入分支 A 时，在 B 分支上的每一次 commit 都会单独添加到 A 分支，而不再像 Merge 方式那样创建一个合并 commit 来合并两个分支的内容3。 首先，切换到 B 分支，接下来将 B 分支变基到 A 分支： 12git checkout Bgit rebase A 现在切回到 A 分支，再执行一次 git merge 命令，即可完成将 B 分支的内容合并到 A 分支的工作。 12git checkout Agit merge B 使用 Rebase 完成合并可以让提交历史线性化，在适当的场景下正确地使用 Rebase 可以达到比 Merge 更好的效果。但是这样做会改变提交历史，在进行 Rebase 时和 Rebase 后再进行相关合并操作时都会增加出现冲突的可能，如果操作不当可能反而会使提交历史变得杂乱。因此，如果对 Rebase 操作没有充分的了解，不建议使用。 管理远程仓库 在本地完成更改后，你可能会需要将这些更改推送到 GitHub 等 Git 仓库托管平台上。托管在这些平台上的仓库就归属于远程仓库的范畴——你可以从这些仓库中获取信息，也可以将你作出的更改推送到远程仓库上。与其他人的协作往往离不开远程仓库，因此学会管理远程仓库很有必要。 远程仓库的查看 使用 git remote 命令可以查看当前仓库的远程仓库列表。 如果当前仓库是克隆来的，那么应该会有一个叫做 origin 的远程仓库，它的链接就是克隆时用的链接。 12$ git remoteorigin 如果要查看某个远程仓库的详细信息的话，可以这样操作： 12345678910$ git remote show origin* remote origin Fetch URL: git@github.com:OI-wiki/OI-wiki.git Push URL: git@github.com:OI-wiki/OI-wiki.git HEAD branch: master Remote branches: git tracked master tracked ... 远程仓库的配置 执行 git remote add &lt;name&gt; &lt;url&gt; 命令可以添加一个名字为 name，链接为 url 的远程仓库。 执行 git remote rename &lt;oldname&gt; &lt;newname&gt; 可以将名字为 oldname 的远程仓库改名为 newname。 执行 git remote rm &lt;name&gt; 可以删除名字为 name 的远程仓库。 执行 git remote get-url &lt;name&gt; 可以查看名字为 name 的远程仓库的链接。 执行 git remote set-url &lt;name&gt; &lt;newurl&gt; 可以将名字为 name 的远程仓库的链接更改为 newurl。 从远程仓库获取更改 在远程仓库中，其他人可能会推送一些更改，执行 git fetch 命令可以将这些更改获取到本地。 1$ git fetch &lt;remote-name&gt; # 获取 &lt;remote-name&gt; 的更改 需要注意的是，git fetch 命令只会获取远程仓库的更改，而不会将这些更改合并到本地仓库中。如果需要将这些更改进行合并，可以使用 git pull 命令。在默认情况下，git pull 相当于 git fetch 后 git merge FETCH_HEAD。 1$ git pull &lt;remote-name&gt; &lt;branch&gt; # 获取 &lt;remote-name&gt; 的更改，然后将这些更改合并到 HEAD 将更改推送到远程仓库 当你完成了一些更改之后，使用 git push 命令可以将这些更改推送到远程仓库。 1$ git push &lt;remote&gt; &lt;from&gt;:&lt;to&gt; # 将本地 &lt;from&gt; 分支的更改推送至 &lt;remote&gt; 的 &lt;to&gt; 分支 根据远程仓库的要求，可能会要求你输入远程仓库账户的用户名和密码。 需要注意的是，你的更改能成功推送，需要满足两个条件：你拥有向这个仓库（分支）的写入权限，且你的这个分支比远程仓库的相应分支新（可以理解为没有人在你进行更改的这段时间进行了推送）。当远程分支有当前分支没有的新更改时，可以执行 git pull 命令完成合并再提交。 如果你需要强制将本地分支的更改推送到远程仓库的话，可以加入 -f 参数。此时 远程仓库的提交历史会被本地的提交历史覆盖，因此该命令应谨慎使用。更好的选择是使用 --force-with-lease 参数，该参数仅在远程仓库没有更新时才会进行覆盖。需要注意的是，此处“更新”是相对于上一次 fetch 而言的，如果使用了 VS Code 提供的 Auto Fetch 功能，可能会没有注意到更新而使 --force-with-lease 和 -f 一样危险。 追踪远程分支 通过将一个本地分支设定为追踪远程分支，可以方便地查看本地分支与远程分支的差别，并能简化与远程分支交互时的操作。 在开始追踪前，你需要先执行 git fetch &lt;remote-name&gt; 将远程仓库的信息抓取到本地。 接下来执行 git switch &lt;remote-branch&gt;，会在本地自动创建名字为 &lt;remote-branch&gt; 的新分支，并设定该分支自动追踪相应的远程分支。 ???+note 需要注意，只有当本地不存在该分支，且恰好只有一个远程分支的名字与该分支匹配时，Git 才会自动创建该分支且设定其追踪相应的远程分支。 这时候执行 git status 命令，会提示当前分支与远程分支之间的差别。 因为设定了本地分支追踪的远程分支，向远程分支推送的命令也被简化了。只需要执行 git push 命令，在本地分支上作出的更改就能被推送至其追踪的远程分支。 对于本地已有的分支，设定其对应的远程追踪分支也很容易。只需在当前分支下执行 git branch -u &lt;remote-name&gt;/&lt;remote-branch&gt;，就可以设定当前的本地分支追踪 &lt;remote-name&gt;/&lt;remote-branch&gt; 这一远程分支。 使用 ssh 连接 与 HTTP(S) 相比，使用 ssh 连接到远程仓库更为方便安全。 在使用 ssh 连接到远程仓库之前，需要先在本地添加 ssh 密钥。接下来需要将本地添加的 ssh 密钥的 公钥 上传到远程仓库账户。 考虑到本文主要是给 OI Wiki 的贡献者提供一个使用 Git 的教程，这里直接给出 GitHub Docs 提供的教程，供各位读者参考。 完成以上步骤后，你就可以通过 ssh 连接到远程仓库了。下面就是一条通过 ssh 连接 clone OI Wiki 仓库的命令： 1$ git clone git@github.com:OI-wiki/OI-wiki.git 将更改推送至远程仓库的过程与使用 HTTP(S) 连接类似。但使用 ssh 连接可以免去验证远程仓库帐号密码的过程。 Git GUI Tools 对于不熟悉命令行的同学，纯命令行的 Git 的上手难度可能会偏高，而借助 GUI 工具可以一定程度上降低 Git 的上手难度。此外，相比于命令行，GUI 工具在查看 diff 以及 log 时在体验上有一定程度的提高。 Git 本身自带有 GUI，市面上也有很多优秀的 Git GUI 工具，例如针对 Windows 用户的 TortoiseGit4，支持 Windows 和 Mac 的 Sourcetree5等。 这里简单介绍一下 TortoiseGit 的使用。下载并安装好 TortoiseGit 之后，在本地仓库的目录下，单击鼠标右键，在右键菜单中就可以看到 Git 的各个功能。 详细的使用方法这里不再赘述，可以参考官网里的使用文档或者通过搜索引擎学习，例如 TortoiseGit Manual。 很多 GUI 工具都有官方中文支持，例如 Git Desktop 以及 TortoiseGit。但是还是会有部分翻译看起来较为变扭，推荐使用英文版本。 外部链接 Git Reference Pro Git Book Learn Git Branching 参考资料与注释 但是，Git for Windows 对 Vim 的描述是“虽然强大，但是可能会难以使用。用户界面反人类，键位映射卡手。Git 使用 Vim 作为默认编辑器只是出于历史原因，强烈推荐换用一个 UI 设计现代化的编辑器。”，并给“难以使用”加上了 Stack Overflow 每年帮助一百万名开发者退出 Vim 的页面链接。↩︎ 事实上 Git 还有一个针对系统上每一个用户及系统上所有仓库的通用配置文件，该配置文件覆盖范围最广，等级在用户配置文件之上。因为该配置实践中较少使用，这里不再展开。↩︎ Pro Git Book 中提供了可视化的 Rebase 过程图，借助图片读者可以更好地理解 Rebase 的机制。↩︎ TortoiseGit↩︎ Sourcetree↩︎","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"}]},{"title":"WSL(在Windows上运行Linux)","date":"2022-09-02T12:11:22.000Z","path":"wiki/WSL/","text":"引入 Windows 10 在一周年更新时推出了 Linux 子系统（WSL），在 2020 年 5 月更新中升级到了 WSL 2。截至 2020 年 6 月 1 日，WSL 已支持安装 Ubuntu、openSUSE Leap、Kali、Debian 等主流 Linux 分发版。但 WSL 并不支持 NOI 评测用的 Arbiter。 什么是 Linux 子系统（WSL） \" 适用于 Linux 的 Windows 子系统（英语：Windows Subsystem for Linux，简称 WSL）是一个为在 Windows 10、Windows 11 与 Windows Server 2019 上能够原生运行 Linux 二进制可执行文件（ELF 格式）的兼容层。 WSL 可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生虚拟机开销。 WSL 仅在版本 1607 之后的 64 位版本的 Windows 10 中可用。它也可在 Windows Server 2019 中使用。 启用 WSL1 自动安装 本部分适用于 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11。如果你正在使用 2004 以下版本或你的电脑不支持虚拟化，请阅读下面的手动安装一节。如果你正在使用 Windows 10 1607 以下版本的 Windows，你的系统不支持 WSL。 以管理员身份打开 Windows Powershell（右击 \"开始\" 按钮，选择 Windows PowerShell（管理员）或 Windows 终端（管理员）) 输入 wsl --install，并等待所有组件自动安装完成。期间你可能需要重启你的计算机来启用必要的 Windows 功能。 安装完成后，你可以在 \"开始\" 菜单或 Windows 终端的标签页中找到你安装的发行版。 接下来，请转到下面“配置分发版”一节完成其他设置。 手动安装2 下面介绍手动安装 WSL 的步骤。如果你已经完成了自动安装，请跳过此部分。 启用适用于 Linux 的 Windows 子系统 在安装适用于 WSL 的任何 Linux 分发版之前，必须在下述两种方法中选择一种，以确保启用“适用于 Linux 的 Windows 子系统”可选功能： 使用命令行： 以管理员身份打开 PowerShell 并运行： 123Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux# 如果你只想要使用 WSL 1 请跳过此步骤Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform 出现提示时，重启计算机。 使用图形界面： 打开“控制面板” 访问“程序和功能”子菜单“打开或关闭 Windows 功能” 选择 \"适用于 Linux 的 Windows 子系统\" 与 \"虚拟机平台\" 点击确定 重启 安装内核更新包 如果你想要使用 WSL 1, 请跳过此步骤。 下载 适用于 x64 计算机的 WSL2 Linux 内核更新包 并安装。 设置 WSL 默认版本 绝大部分情况下，建议使用 WSL 2。 WSL 1 与 WSL 2 的区别，请见 比较 WSL 2 和 WSL 1 \"关于 systemd\" WSL 1 完全不支持 systemd（这意味着一些需要 systemd 的功能无法实现或需要别的 hack），WSL 2 可以使用 genie。 此外，yuk7/arch-systemctl-alt 项目提供了一个在 WSL 1 与 2 都可用的 alternative script，但是它只具有部分兼容且只在 ArchWSL 进行了测试。 12# 将 WSL 默认版本设置为 WSL 2wsl --set-default-version 2 安装 WSL 分发版 进入 Microsoft Store，搜索“Ubuntu”，然后选择“Ubuntu”，点击“安装”进行安装。也可打开 Ubuntu 的商店页面。 Microsoft Store 的 Ubuntu 随着 Ubuntu 的更新而更新，因此内容可能会有所改变。如果想获取稳定的 Ubuntu 长期支持版，可以在 Microsoft Store 安装 Ubuntu 的 LTS 版本。 配置分发版3 本章以 Windows 自动安装的 Ubuntu 为例。 运行 Ubuntu 打开“开始”菜单找到 Ubuntu 并启动，或使用 wsl 命令从 Windows 命令行启动。 可以为 Ubuntu 创建应用程序磁贴或固定至任务栏，以在下次方便地打开。 初始化 第一次运行 Ubuntu，需要完成初始化。 Installing, this may take a few minutes... 等待一两分钟时间，系统会提示创建新的用户帐户。 Please create a default UNIX user account. The username does not need to match your Windows username. For more information visit: https://aka.ms/wslusers Enter new UNIX username: chtholly 输入完用户名以后会提示输入密码。在 Linux 中，输入密码时屏幕上不显示文字属于正常现象。 Enter new UNIX password: 设置好帐户名和密码后，WSL 就安装完成了。 Installation successful! To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;. See &quot;man sudo_root&quot; for details. chtholly@SENIORIOUS:~$ 基础配置 初次安装好的系统不附带任何 C/C++ 编译器，需要手动配置环境。 123456$ gccThe program &#x27;gcc&#x27; is currently not installed. You can install it by typing:sudo apt install gcc$ g++The program &#x27;g++&#x27; is currently not installed. You can install it by typing:sudo apt install g++ 更换为国内软件源 Ubuntu 默认的软件源在国外。可以换成国内的软件源以加快速度，如 清华 TUNA 的软件源。 \"使用与自己系统版本匹配的软件源\"。 请在页面中寻找与自己系统版本相配的源（可使用 sudo lsb_release -a 查看 Ubuntu 版本）。 除非你知道你在做什么，否则不要使用与自己的系统版本不匹配的源！ 使用以下命令更新软件和软件源： 12345# cp /etc/apt/sources.list /etc/apt/sources.list.bak# vim /etc/apt/sources.list...（按 i 之后将上文的源右键粘贴进去，编辑完后按 Esc，再输入 :wq 和回车）# apt update# apt upgrade -y 安装中文环境 1234567# apt install language-pack-zh-han* -y# locale-gen zh_CN.GB18030 &amp;&amp; locale-gen zh_CN.UTF-8# apt install fontconfig -y# apt install fonts-noto-cjk -y # 中文字体# apt install fonts-wqy-microhei -y# apt install fonts-wqy-zenhei -y# dpkg-reconfigure locales 使用 sudo dpkg-reconfigure locales 进入菜单，按空格选择带 zh_CN 的选项（推荐 zh_CN.UTF-8 UTF-8），选完后回车。 Locales to be generated: ... [ ] zh_CN.GBK GBK [*] zh_CN.UTF-8 UTF-8 [ ] zh_HK BIG5-HKSCS ... &lt;Ok&gt; &lt;Cancel&gt; 下一个菜单中选择 zh_CN.UTF-8 回车。 Default locale for the system environment: None C.UTF-8 en_US.UTF-8 [zh_CN.UTF-8] &lt;Ok&gt; &lt;Cancel&gt; 之后关闭 WSL 并重启，系统就会变成中文。 再依次输入下列命令，把 man 帮助页替换为中文。4 12# apt install manpages-zh# sed -i &#x27;s|/usr/share/man|/usr/share/man/zh_CN|g&#x27; /etc/manpath.config 可以用 man help 测试。 安装编译环境5 1# apt install -y build-essential vim ddd gdb fpc emacs gedit anjuta lazarus GUIDE 的安装请参考 Debian 或 Ubuntu 下 GUIDE 的安装。 这里安装的是基础 + NOI 官方要求的环境，如有需要可以用 apt install &lt;程序名&gt; 来安装其它软件包。 若想安装其他版本可以参考 Debian 官方的 包管理手册。 以下为一个示例程序： 12345$ vim cpuid.cpp...$ g++ -Wall cpuid.cpp -o cpuid$ ./cpuidAMD Ryzen 5 1400 Quad-Core Processor Linux 环境下可执行文件可不带扩展名，实现方式看上方命令。 进阶操作 使用 WSLg 运行 GUI 程序 如果你使用 Windows 11 Build 22000 以上版本，则可以使用 WSL 2 提供的集成的桌面体验。该功能允许你直接安装并启动 Linux 桌面程序而无须其他配置。 参见 在适用于 Linux 的 Windows 子系统上运行 Linux GUI 应用（预览） 安装图形环境，并使用远程桌面连接 如果你使用的版本尚不支持 WSLg, 可以尝试使用以下指南开启图形界面功能。 以下以 Xfce 为例。 如果只想安装 Xfce，可以执行以下命令： 1# apt install xfce4 tightvncserver -y 如果除 Xfce 外想要更多的软件，可以执行以下命令： 1# sudo apt install xubuntu-desktop -y 图形环境文件较大，下载解包需要一定时间。 配置 xrdp： 123# apt install xrdp -y$ echo &quot;xfce4-session&quot; &gt;~/.xsession# service xrdp restart 为了防止和计算机本来带的远程桌面冲突，最好换一下端口。 运行命令 sudo sed 's/port=[0-9]&#123;1,5&#125;/port=otherport/' /etc/xrdp/xrdp.ini，其中 otherport 为其他端口（如 3390）。 [globals] ... port=3390 运行 sudo service xrdp restart，然后去开始菜单，用 localhost:otherport 来访问。 使用 Xming 连接 进入 Ubuntu 环境，安装 xterm： 1# apt install xterm -y 退出 Ubuntu。 从 Xming X Server 下载地址 下载最新的 Xming Server，然后安装： 如果安装完后忘记勾选 Launch Xming，需在开始菜单里打开 Xming： 之后再回到 Ubuntu，键入如下指令： 1$ DISPLAY=:0 xterm 如果使用了 xfce4，可以在弹出的窗口中使用如下命令激活 xfce4： 1$ xfce4-session 运行结果如图。（在 Xming 中使用Ctrl+C就可以退出该界面。） WSL 与 Windows 文件的互访问 Windows 下的硬盘被自动挂载至 Linux 环境下的 /mnt 文件夹下。 如 C 盘在 WSL 下的路径为 /mnt/c 123456789PS C:\\Users\\chtholly&gt; bash/mnt/c/Users/chtholly$ echo &quot;Hello world!&quot; &gt; hello/mnt/c/Users/chtholly$ exitPS C:\\Users\\chtholly&gt; cat helloHello world!PS C:\\Users\\chtholly&gt; echo &quot;Welcome!&quot; &gt; welcomePS C:\\Users\\chtholly&gt; bash/mnt/c/Users/chtholly$ cat welcomeWelcome! 相对的，也可以从文件管理器访问 WSL 目录。在安装 WSL 后，可以在资源管理器的侧边栏中发现 Linux 项，在其中可以访问所有安装的发行版其中的文件。 同样，也可以在资源管理器的路径或运行（Win+R）中直接输入 \\\\wsl$ 来转到 WSL 的目录。 也可以直接使用诸如 \\\\wsl$\\Ubuntu\\home\\ 的路径访问其子文件夹。 配合 Visual Sudio Code 进行编辑 如果习惯在 Windows 环境下使用 Visual Studio Code 进行代码编辑，可以安装 VSC 中的 Remote - WSL 插件，更方便地对 WSL 系统中的文件进行编辑。 通过 Remote - WSL，可以在 Windows 下的 VS Code 界面中直接对 WSL 子系统进行操作，更加方便地编辑子系统目录下的文件、更方便地使用终端进行调试。 通过在 WSL 中直接键入 code .，可以在该目录下直接唤出 Visual Studio Code，对于该目录下的文件进行编辑。 同时，可以通过类似 code filename 的命令，对于指定文件进行编辑。 在插件 Remote - WSL 的 Getting Started 页面，包含对于编辑操作的详细简介。 同时，也可以参考 Visual Studio Code 的官方文档中关于 WSL 的内容（Remote development in WSL），这篇文章包含从 WSL 安装到配合插件使用的全流程的更详细的介绍。 FAQ 参见：常见问题，WSL 2 常见问题解答 如何在子系统下进行 xxx？ 可以用自带命令行，或者使用图形界面。 比如说 vim，在命令行中键入 man vim，会给出一份详尽的使用方法。 亦可使用 vim --help。 关于命令行，可阅读 命令行 对系统资源的占用量？ 这个系统和 Windows 10 共用 Host，所以理论上是比虚拟机占用小的。 外部链接 关于适用于 Linux 的 Windows 子系统 Ubuntu 镜像使用帮助，清华 TUNA Dev on Windows with WSL（在 Windows 上用 WSL 优雅开发） GitHub 上的 Awesome-WSL 排查适用于 Linux 的 Windows 子系统问题 参考资料与注释 安装 WSL, Microsoft Docs↩︎ 旧版 WSL 的手动安装步骤↩︎ WSL-Ubuntu 维基，ubuntu wiki↩︎ Ubuntu 的 man 命令帮助如何设置中文版，Frank 看庐山，2017-06-09↩︎ Run Bash on Ubuntu on Windows, Mike Harsh, 2016-05-30, Windows Blog↩︎","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"}]},{"title":"Latex","date":"2022-09-02T09:26:39.000Z","path":"wiki/Latex/","text":"介绍 什么是 LaTeX LaTeX（读作/ˈlɑːtɛx/或/ˈleɪtɛx/）是一个让你的文档看起来更专业的排版系统，而不是文字处理器。它尤其适合处理篇幅较长、结构严谨的文档，并且十分擅长处理公式表达。它是免费的软件，对大多数操作系统都适用。 LaTeX 基于 TeX（Donald Knuth 在 1978 年为数字化排版设计的排版系统）。TeX 是一种电脑能够处理的低级语言，但大多数人发现它很难使用。LaTeX 正是为了让它变得更加易用而设计的。目前 LaTeX 的版本是 LaTeX 2e。 如果你习惯于使用微软的 Office Word 处理文档，那么你会觉得 LaTeX 的工作方式让你很不习惯。Word 是典型的“所见即所得”的编辑器，你可以在编排文档的时侯查看到最终的排版效果。但使用 LaTeX 时你并不能方便地查看最终效果，这使得你专注于内容而不是外观的调整。 一个 LaTeX 文档是一个以 .tex 结尾的文本文件，可以使用任意的文本编辑器编辑，比如 Notepad，但对于大多数人而言，使用一个合适的 LaTeX 编辑器会使得编辑的过程容易很多。在编辑的过程中你可以标记文档的结构。完成后你可以进行编译——这意味着将它转化为另一种格式的文档。它支持多种格式，但最常用的是 PDF 文档格式。 在开始之前 下面列出在本文中使用到的记号： 希望你实施的操作会被打上一个箭头 \\(\\rightarrow\\)； 你输入的字符会被装进代码块中； 菜单命令与按钮的名称会被标记为 粗体。 一些概念 如果需要编写 LaTeX 文档，你需要安装一个「发行版」，常用的发行版有 TeX Live、MikTeX 和适用于 macOS 用户的 MacTeX（实际上是 TeX Live 的 macOS 版本），至于 CTeX 则现在不推荐使用。TeX Live 和 MacTeX 带有几乎所有的 LaTeX 宏包；而 MikTeX 只带有少量必须的宏包，其他宏包将在需要时安装。 TeX Live 和 MikTeX 都带有 TeXworks 编辑器，你也可以安装功能更多的 TeXstudio 编辑器，或者自行配置 Visual Studio Code 或 Notepad++ 等编辑器。下文所使用的编辑器是运行在 Windows 7 上的 TeXworks。 大部分发行版都带有多个引擎，如 pdfTeX 和 XeTeX。对于中文用户，推荐使用 XeTeX 以获得 Unicode 支持。 TeX 有多种格式，如 Plain TeX 和 LaTeX。现在一般使用 LaTeX 格式。所以，你需要使用与你所使用的格式打包在一起的引擎。如对于 pdfTeX，你需要使用 pdfLaTeX，对于 XeTeX 则是 XeLaTeX。 扩展阅读：TeX 引擎、格式、发行版之介绍。 环境配置 对于 Windows 用户，你需要下载 TeX Live 或 MikTeX。国内用户可以使用 清华大学 TUNA 镜像站，请点击页面右侧的「获取下载链接」按钮，并选择「应用软件」标签下的「TeX 排版系统」即可下载 TeX Live 或 MikTeX 的安装包，其中 TeX Live 的安装包是一个 ISO 文件，需要挂载后以管理员权限执行 install-tl-advanced.bat。 对于 macOS 用户，清华大学 TUNA 镜像站同样提供 MacTeX 和 macOS 版 MikTeX 的下载。 对于 Linux 用户，如果使用 TeX Live，则同样下载 ISO 文件，执行 install-tl 脚本；如果使用 MikTeX，则按照 官方文档 进行安装。 文档结构 基本要素 \\(\\rightarrow\\) 打开 TeXworks。 一个新的文档会被自动打开。 \\(\\rightarrow\\) 进入 Format 菜单，选择 Line Numbers。 行号并不是要素，但它可以帮助你比较代码与屏幕信息，找到错误。 \\(\\rightarrow\\) 进入 Format 菜单，选择 Syntax Coloring，然后选择 LaTeX。 语法色彩会高亮代码，使得代码更加易读。 \\(\\rightarrow\\) 输入以下文字： 1234567\\documentclass[a4paper,12pt]&#123;article&#125;\\begin&#123;document&#125;A sentence of text.\\end&#123;document&#125; \\documentclass 命令必须出现在每个 LaTeX 文档的开头。花括号内的文本指定了文档的类型。article 文档类型适合较短的文章，比如期刊文章和短篇报告。其他文档类型包括 report（适用于更长的多章节的文档，比如博士生论文），proc（会议论文集），book 和 beamer。方括号内的文本指定了一些选项——示例中它设置纸张大小为 A4，主要文字大小为 12pt。 \\begin&#123;document&#125; 和 \\end&#123;document&#125; 命令将你的文本内容包裹起来。任何在 \\begin&#123;documnet&#125; 之前的文本都被视为前导命令，会影响整个文档。任何在 \\end&#123;document&#125; 之后的文本都会被忽视。 空行不是必要的，但它可以让长的文档更易读。 \\(\\rightarrow\\) 按下 Save 按扭；\\(\\rightarrow\\) 在 Libraries&gt;Documents 中新建一个名为 LaTeX course 文件夹；\\(\\rightarrow\\) 将你的文档命名为 Doc1 并将其保存为 TeX document 放在这个文件夹中。 将不同的 LaTeX 文档放在不同的目录下，在编译的时候组合多个文件是一个很好的想法。 \\(\\rightarrow\\) 确保 typeset 菜单设置为了 xeLaTeX。\\(\\rightarrow\\) 点击 Typeset 按扭。 这时你的源文件会被转换为 PDF 文档，这需要花费一定的时间。在编译结束后，TeXworks 的 PDF 查看器会打开并预览生成的文件。PDF 文件会被自动地保存在与 TeX 文档相同的目录下。 处理问题 如果在你的文档中存在错误，TeXworks 无法创建 PDF 文档时，Typeset 按扭会变成一个红叉，并且底部的终端输出会保持展开。这时： \\(\\rightarrow\\) 点击 Abort typesetting 按扭。\\(\\rightarrow\\) 阅读终端输出的内容，最后一行可能会给出行号表示出现错误的位置。\\(\\rightarrow\\) 找到文档中对应的行并修复错误。\\(\\rightarrow\\) 再次点击 Typeset 按扭尝试编译源文件。 添加文档标题 \\maketitle 命令可以给文档创建标题。你需要指定文档的标题。如果没有指定日期，就会使用现在的时间，作者是可选的。 \\(\\rightarrow\\) 在 \\begin&#123;document&#125; 和 命令后紧跟着输入以下文本： 1234\\title&#123;My First Document&#125;\\author&#123;My Name&#125;\\date&#123;\\today&#125;\\maketitle 你的文档现在长成了这样： 123456789101112\\documentclass[a4paper,12pt]&#123;article&#125;\\begin&#123;document&#125;\\title&#123;My First Document&#125;\\author&#123;My Name&#125;\\date&#123;\\today&#125;\\maketitleA sentence of text.\\end&#123;document&#125; \\(\\rightarrow\\) 点击 Typeset 按扭，核对生成的 PDF 文档。 要点笔记： \\today 是插入当前时间的命令。你也可以输入一个不同的时间，比如 \\data&#123;November 2013&#125;。 article 文档的正文会紧跟着标题之后在同一页上排版。report 会将标题置为单独的一页。 章节 如果需要的话，你可能想将你的文档分为章（Chatpers）、节（Sections）和小节（Subsections）。下列分节命令适用于 article 类型的文档： \\section&#123;...&#125; \\subsection&#123;...&#125; \\subsubsection&#123;...&#125; \\paragraph&#123;...&#125; \\subparagraph&#123;...&#125; 花括号内的文本表示章节的标题。对于 report 和 book 类型的文档我们还支持 \\chapter&#123;...&#125; 的命令。 \\(\\rightarrow\\) 将 \"A sentence of text.\" 替换为以下文本： 12345678910111213\\section&#123;Introduction&#125;This is the introduction.\\section&#123;Methods&#125;\\subsection&#123;Stage 1&#125;The first part of the methods.\\subsection&#123;Stage 2&#125;The second part of the methods.\\section&#123;Results&#125;Here are my results. 你的文档会变成 123456789101112131415161718192021222324\\documentclass[a4paper,12pt]&#123;article&#125;\\begin&#123;document&#125;\\title&#123;My First Document&#125;\\author&#123;My Name&#125;\\date&#123;\\today&#125;\\maketitle\\section&#123;Introduction&#125;This is the introduction.\\section&#123;Methods&#125;\\subsection&#123;Stage 1&#125;The first part of the methods.\\subsection&#123;Stage 2&#125;The second part of the methods.\\section&#123;Results&#125;Here are my results.\\end&#123;document&#125; \\(\\rightarrow\\) 点击 Typeset 按扭，核对 PDF 文档。应该是长这样的： p1 创建标签 你可以对任意章节命令创建标签，这样他们可以在文档的其他部分被引用。使用 \\label&#123;labelname&#125; 对章节创建标签。然后输入 \\ref&#123;labelname&#125; 或者 \\pageref&#123;labelname&#125; 来引用对应的章节。 \\(\\rightarrow\\) 在 \\subsection&#123;Stage 1&#125; 下面另起一行，输入 \\label&#123;sec1&#125;。\\(\\rightarrow\\) 在 Results 章节输入 Referring to section \\ref&#123;sec1&#125; on page \\pageref&#123;sec1&#125;。 你的文档会变成这样： 12345678910111213141516171819202122232425\\documentclass[a4paper,12pt]&#123;article&#125;\\begin&#123;document&#125;\\title&#123;My First Document&#125;\\author&#123;My Name&#125;\\date&#123;\\today&#125;\\maketitle\\section&#123;Introduction&#125;This is the introduction.\\section&#123;Methods&#125;\\subsection&#123;Stage 1&#125;\\label&#123;sec1&#125;The first part of the methods.\\subsection&#123;Stage 2&#125;The second part of the methods.\\section&#123;Results&#125;Here are my results. Referring to section \\ref&#123;sec1&#125; on page \\pageref&#123;sec1&#125;\\end&#123;document&#125; \\(\\rightarrow\\) 编译并检查 PDF 文档（你可能需要连续编译两次）： p2 生成目录（TOC） 如果你使用分节命令，那么可以容易地生成一个目录。使用 \\tableofcontents 在文档中创建目录。通常我们会在标题的后面建立目录。 你可能也想也想更改页码为罗马数字（i,ii,iii）。这会确保文档的正文从第 1 页开始。页码可以使用 \\pagenumbering&#123;...&#125; 在阿拉伯数字和罗马数字见切换。 \\(\\rightarrow\\) 在 \\maketitle 之后输入以下内容： 1234\\pagenumbering&#123;roman&#125;\\tableofcontents\\newpage\\pagenumbering&#123;arabic&#125; \\newpage 命令会另起一个页面，这样我们就可以看到 \\pagenumbering 命令带来的影响了。你的文档的前 14 行长这样： 12345678910111213\\documentclass[a4paper,12pt]&#123;article&#125;\\begin&#123;document&#125;\\title&#123;My First Document&#125;\\author&#123;My Name&#125;\\date&#123;\\today&#125;\\maketitle\\pagenumbering&#123;roman&#125;\\tableofcontents\\newpage\\pagenumbering&#123;arabic&#125; \\(\\rightarrow\\) 编译并核对文档（可能需要多次编译，下文不赘述）。 文档的第一页长这样： p3 第二页： p4 文字处理 中文字体支持 阅读本文学习 LaTeX 的人，首要学会的自然是 LaTeX 的中文字体支持。事实上，让 LaTeX 支持中文字体有许多方法。在此我们仅给出最 简洁 的解决方案：使用 CTeX 宏包。只需要在文档的前导命令部分添加： 1\\usepackage[UTF8]&#123;ctex&#125; 就可以了。在编译文档的时侯使用 xelatex 命令，因为它是支持中文字体的。 字体效果 LaTeX 有多种不同的字体效果，在此列举一部分： 12345678\\textit&#123;words in italics&#125;\\textsl&#123;words slanted&#125;\\textsc&#123;words in smallcaps&#125;\\textbf&#123;words in bold&#125;\\texttt&#123;words in teletype&#125;\\textsf&#123;sans serif words&#125;\\textrm&#123;roman words&#125;\\underline&#123;underlined words&#125; 效果如下： p5 \\(\\rightarrow\\) 在你的文档中添加更多的文本并尝试各种字体效果。 彩色字体 为了让你的文档支持彩色字体，你需要使用包（package）。你可以引用很多包来增强 LaTeX 的排版效果。包引用的命令放置在文档的前导命令的位置（即放在 \\begin&#123;document&#125; 命令之前）。使用 \\usepackage[options]&#123;package&#125; 来引用包。其中 package 是包的名称，而 options 是指定包的特征的一些参数。 使用 \\usepackage&#123;color&#125; 后，我们可以调用常见的颜色： p6 使用彩色字体的代码为 1&#123;\\color&#123;colorname&#125;text&#125; 其中 colorname 是你想要的颜色的名字，text 是你的彩色文本内容。注意到示例效果中的黄色与白色是有文字背景色的，这个我们同样可以使用 Color 包中的 \\colorbox 命令来达到。用法如下： 1\\colorbox&#123;colorname&#125;&#123;text&#125; \\(\\rightarrow\\) 在 \\begin&#123;document&#125; 前输入 \\usepackage&#123;color&#125;。\\(\\rightarrow\\) 在文档内容中输入 &#123;\\color&#123;red&#125;fire&#125;。\\(\\rightarrow\\) 编译并核对 PDF 文档内容。 单词 fire 应该是红色的。 你也可以添加一些参数来调用更多的颜色，甚至自定义你需要的颜色。但这部分超出了本书的内容。如果想要获取更多关于彩色文本的内容请阅读 LaTeX Wikibook 的 Colors 章节。 字体大小 接下来我们列举一些 LaTeX 的字体大小设定命令： 123456789normal size words&#123;\\tiny tiny words&#125;&#123;\\scriptsize scriptsize words&#125;&#123;\\footnotesize footnotesize words&#125;&#123;\\small small words&#125;&#123;\\large large words&#125;&#123;\\Large Large words&#125;&#123;\\LARGE LARGE words&#125;&#123;\\huge huge words&#125; 效果如下： p7 \\(\\rightarrow\\) 尝试为你的文本调整字体大小。 段落缩进 LaTeX 默认每个章节第一段首行顶格，之后的段落首行缩进。如果想要段落顶格，在要顶格的段落前加 \\noindent 命令即可。如果希望全局所有段落都顶格，在文档的某一位置使用 \\setlength&#123;\\parindent&#125;&#123;0pt&#125; 命令，之后的所有段落都会顶格。 列表 LaTeX 支持两种类型的列表：有序列表（enumerate）和无序列表（itemize）。列表中的元素定义为 \\item。列表可以有子列表。 \\(\\rightarrow\\) 输入下面的内容来生成一个有序列表套无序列表： 123456789\\begin&#123;enumerate&#125;\\item First thing\\item Second thing\\begin&#123;itemize&#125;\\item A sub-thing\\item Another sub-thing\\end&#123;itemize&#125;\\item Third thing\\end&#123;enumerate&#125; \\(\\rightarrow\\) 编译并核对 PDF 文档。 列表长这样： p8 可以使用方括号参数来修改无序列表头的标志。例如，\\item[-] 会使用一个杠作为标志，你甚至可以使用一个单词，比如 \\item[One]。 下面的代码： 123456789\\begin&#123;itemize&#125;\\item[-] First thing\\item[+] Second thing\\begin&#123;itemize&#125;\\item[Fish] A sub-thing\\item[Plants] Another sub-thing\\end&#123;itemize&#125;\\item[Q] Third thing\\end&#123;itemize&#125; 生成的效果为 p9 注释和空格 我们使用 % 创建一个单行注释，在这个字符之后的该行上的内容都会被忽略，直到下一行开始。 下面的代码： 1234It is a truth universally acknowledged% Note comic ironyin the very first sentence, that a single man in possession of a good fortune, mustbe in want of a wife. 生成的结果为 p10 多个连续空格在 LaTeX 中被视为一个空格。多个连续空行被视为一个空行。空行的主要功能是开始一个新的段落。通常来说，LaTeX 忽略空行和其他空白字符，两个反斜杠（\\\\）可以被用来换行。 \\(\\rightarrow\\) 尝试在你的文档中添加注释和空行。 如果你想要在你的文档中添加空格，你可以使用 \\vaspace&#123;...&#125; 的命令。这样可以添加竖着的空格，高度可以指定。如 \\vspace&#123;12pt&#125; 会产生一个空格，高度等于 12pt 的文字的高度。 特殊字符 下列字符在 LaTeX 中属于特殊字符： 1# $ % ^ &amp; _ &#123; &#125; ~ \\ 为了使用这些字符，我们需要在他们前面添加反斜杠进行转义： 1\\# \\$ \\% \\^&#123;&#125; \\&amp; \\_ \\&#123; \\&#125; \\~&#123;&#125; 注意在使用 ^ 和 ~ 字符的时侯需要在后面紧跟一对闭合的花括号，否则他们就会被解释为字母的上标，就像 \\^ e 会变成 \\(\\mathrm {\\hat{e}}\\)。上面的代码生成的效果如下： p11 注意，反斜杠不能通过反斜杠转义（不然就变成了换行了），使用 \\textbackslash 命令代替。 \\(\\rightarrow\\) 输入代码来在你的文档中生成下面内容： p12 询问专家或者查看本书的 TeX 源代码获取帮助。 表格 表格（tabular）命令用于排版表格。LaTeX 默认表格是没有横向和竖向的分割线的——如果你需要，你得手动设定。LaTeX 会根据内容自动设置表格的宽度。下面的代码可以创一个表格： 1\\begin&#123;tabular&#125;&#123;...&#125; 省略号会由定义表格的列的代码替换： l 表示一个左对齐的列； r 表示一个右对齐的列； c 表示一个向中对齐的列； | 表示一个列的竖线； 例如，&#123;lll&#125; 会生成一个三列的表格，并且保存向左对齐，没有显式的竖线；&#123;|l|l|r|&#125; 会生成一个三列表格，前两列左对齐，最后一列右对齐，并且相邻两列之间有显式的竖线。 表格的数据在 \\begin&#123;tabular&#125; 后输入： &amp; 用于分割列； \\\\ 用于换行； \\hline 表示插入一个贯穿所有列的横着的分割线； \\cline&#123;1-2&#125; 会在第一列和第二列插入一个横着的分割线。 最后使用 \\end&#123;tabular&#125; 结束表格。举一些例子： 1234567891011121314151617181920212223\\begin&#123;tabular&#125;&#123;|l|l|&#125;Apples &amp; Green \\\\Strawberries &amp; Red \\\\Orange &amp; Orange\\\\\\end&#123;tabular&#125;\\begin&#123;tabular&#125;&#123;rc&#125;Apples &amp; Green\\\\\\hline Strawberries &amp; Red \\\\\\cline&#123;1-1&#125;Oranges &amp; Orange \\\\\\end&#123;tabular&#125;\\begin&#123;tabular&#125;&#123;|r|l|&#125;\\hline8 &amp; here&#x27;s \\\\\\cline&#123;2-2&#125;86 &amp; stuff\\\\\\hline \\hline 2008 &amp; now \\\\\\hline \\end&#123;tabular&#125; 效果如下： p13 实践 尝试画出下列表格： p14 图表 本章介绍如何在 LaTeX 文档中插入图表。这里我们需要引入 graphicx 包。图片应当是 PDF，PNG，JPEG 或者 GIF 文件。下面的代码会插入一个名为 myimage 的图片： 123456\\begin&#123;figure&#125;[h]\\centering\\includegraphics[width=1\\textwidth]&#123;myimage&#125;\\caption&#123;Here is my image&#125;\\label&#123;image-myimage&#125;\\end&#123;figure&#125; [h] 是位置参数，h 表示把图表近似地放置在这里（如果能放得下）。有其他的选项：t 表示放在在页面顶端；b 表示放在在页面的底端；p 表示另起一页放置图表。你也可以添加一个 ! 参数来强制放在参数指定的位置（尽管这样排版的效果可能不太好）。 \\centering 将图片放置在页面的中央。如果没有该命令会默认左对齐。使用它的效果是很好的，因为图表的标题也是居中对齐的。 \\includegraphics&#123;...&#125; 命令可以自动将图放置到你的文档中，图片文件应当与 TeX 文件放在同一目录下。 [width=1\\textwidth] 是一个可选的参数，它指定图片的宽度——与文本的宽度相同。宽度也可以以厘米为单位。你也可以使用 [scale=0.5] 将图片按比例缩小（示例相当于缩小一半）。 \\caption&#123;...&#125; 定义了图表的标题。如果使用了它，LaTeX 会给你的图表添加“Figure”开头的序号。你可以使用 \\listoffigures 来生成一个图表的目录。 \\label&#123;...&#125; 创建了一个可以供你引用的标签。 实践 \\(\\rightarrow\\) 在你文档的前导命令中添加 \\usepackage&#123;graphicx&#125;。\\(\\rightarrow\\) 找到一张图片，放置在你的 LaTeX course 文件夹下。\\(\\rightarrow\\) 在你想要添加图片的地方输入以下内容： 12345\\begin&#123;figure&#125;[h!]\\centering\\includegraphics[width=1\\textwidth]&#123;ImageFilename&#125;\\caption&#123;My test image&#125;\\end&#123;figure&#125; 将 ImageFilename 替换为你的文件的名字（不包括后缀）。如果你的文件名有空格，就使用双引号包裹，比如 \"screen 20\"。 \\(\\rightarrow\\) 编译并核对文件。 公式 使用 LaTeX 的主要原因之一是它可以方便地排版公式。我们使用数学模式来排版公式。 插入公式 你可以使用一对 $ 来启用数学模式，这可以用于撰写行内数学公式。例如 $1+2=3$ 的生成效果是 \\(1+2=3\\)。 如果你想要行间的公式，可以使用 $$...$$（现在我们推荐使用 \\[...\\]，因为前者可能产生不良间距）。例如，$$1+2=3$$ 的生产效果为 \\[ 1+2=3 \\] 如果是生成带标号的公式，可以使用 \\begin&#123;equation&#125;...\\end&#123;equation&#125;。例如 \\begin&#123;equation&#125;1+2=3\\end&#123;equation&#125; 生成的效果为： \\[ \\begin{equation}1+2=3\\end{equation} \\] 数字 6 代表的是章节的编号，仅当你的文档有设置章节时才会出现，比如 report 类型的文档。 使用 \\begin&#123;eqnarray&#125;...\\end&#123;eqnarray&#125; 来撰写一组带标号的公式。例如： 1234\\begin&#123;eqnarray&#125;a &amp; = &amp; b + c \\\\ &amp; = &amp; y - z\\end&#123;eqnarray&#125; 生成的效果为 \\[ \\begin{eqnarray} a &amp; = &amp; b + c \\\\ &amp; = &amp; y - z \\end{eqnarray} \\] 要撰写不标号的公式就在环境标志的后面添加 * 字符，如 &#123;equation*&#125;，&#123;eqnarray*&#125;。 数学符号 尽管一些基础的符号可以直接键入，但大多数特殊符号需要使用命令来显示。 本书只是数学符号使用的入门教程，LaTeX Wikibook 的数学符号章节是另一个更好更完整的教程。如果想要了解更多关于数学符号的内容请移步。如果你想找到一个特定的符号，可以使用 Detexfiy，它可以识别手写字符。 上标和下标 上标（Powers）使用 ^ 来表示，比如 $n^2$ 生成的效果为 \\(n^2\\)。 下标（Indices）使用 _ 表示，比如 $2_a$ 生成的效果为 \\(2_a\\)。 如果上标或下标的内容包含多个字符，请使用花括号包裹起来。比如 $b_&#123;a-2&#125;$ 的效果为 \\(b_{a-2}\\)。 分数 分数使用 \\frac&#123;numerator&#125;&#123;denominator&#125; 命令插入。比如 $$\\frac&#123;a&#125;&#123;3&#125;$$ 的生成效果为 \\[ \\frac{a}{3} \\] 分数可以嵌套。比如 $$\\frac&#123;y&#125;&#123;\\frac&#123;3&#125;&#123;x&#125;+b&#125;$$ 的生成效果为 \\[ \\frac{y}{\\frac{3}{x}+b} \\] 根号 我们使用 \\sqrt&#123;...&#125; 命令插入根号。省略号的内容由被开根的内容替代。如果需要添加开根的次数，使用方括号括起来即可。 例如 $$\\sqrt&#123;y^2&#125;$$ 的生成效果为 \\[ \\sqrt{y^2} \\] 而 $$\\sqrt[x]&#123;y^2&#125;$$ 的生成效果为 \\[ \\sqrt[x]{y^2} \\] 求和与积分 使用 \\sum 和 \\int 来插入求和式与积分式。对于两种符号，上限使用 ^ 来表示，而下限使用 _ 表示。 $$\\sum_&#123;x=1&#125;^5 y^z$$ 的生成效果为 \\[ \\sum_{x=1}^5y^z \\] 而 $$\\int_a^b f(x)$$ 的生成效果为 \\[ \\int_a^b f(x) \\] 希腊字母 我们可以使用反斜杠加希腊字母的名称来表示一个希腊字母。名称的首字母的大小写决定希腊字母的形态。例如 $\\alpha$=\\(\\alpha\\) $\\beta$=\\(\\beta\\) $\\delta, \\Delta$=\\(\\delta, \\Delta\\) $\\pi, \\Pi$=\\(\\pi, \\Pi\\) $\\sigma, \\Sigma$=\\(\\sigma, \\Sigma\\) $\\phi, \\Phi, \\varphi$=\\(\\phi, \\Phi, \\varphi\\) $\\psi, \\Psi$=\\(\\psi, \\Psi\\) $\\omega, \\Omega$=\\(\\omega, \\Omega\\) 实践 \\(\\rightarrow\\) 撰写代码来生成下列公式： p15 如果需要帮助，可以查看本书的 TeX 源码。 参考文献 介绍 LaTeX 可以轻松插入参考文献以及目录。本文会介绍如何使用另一个 BibTeX 文件来存储参考文献。 BibTeX 文件类型 BibTeX 文件包含了所有你想要在你文档中引用的文献。它的文件后缀名为 .bib。它的名字应设置为你的 TeX 文档的名字。.bib 文件是文本文件。你需要将你的参考文献按照下列格式输入： 123456789@article&#123; Birdetal2001, Author = &#123;Bird, R. B. and Smith, E. A. and Bird, D. W.&#125;, Title = &#123;The hunting handicap: costly signaling in human foraging strategies&#125;, Journal = &#123;Behavioral Ecology and Sociobiology&#125;, Volume = &#123;50&#125;, Pages = &#123;9-19&#125;, Year = &#123;2001&#125; &#125; 每一个参考文献先声名它的文献类型（reference type）。示例中使用的是 @article，其他的类型包括 @book，@incollection 用于引用一本书的中的章节，@inproceedings 用于引用会议论文。可以 在此 查看更多支持的类型。 接下来的花括号内首先要列出一个引用键值（citation key）。必须保证你引用的文献的引用键值是不同的。你可以自定义键值串，不过使用第一作者名字加上年分会是一个表义清晰的选择。 接下来的若干行包括文献的若干信息，格式如下： 1Field name = &#123;field contents&#125;, 你可以使用 LaTeX 命令来生成特殊的文字效果。比如意大利斜体可以使用 \\emph&#123;Rattus norvegicus&#125;。 对于需要大写的字母，请用花括号包裹起来。BibTeX 会自动把标题中除第一个字母外所有大写字母替换为小写。比如 Dispersal in the contemporary United States 的生成效果为 \\(\\text{Dispersal in the contemporary united states}\\)，而 Dispersal in the contemporary &#123;U&#125;nited &#123;S&#125;tates 的生成效果为 \\(\\text{Dispersal in the contemporary United States}\\)。 你可以手写 BibTeX 文件，也可以使用软件来生成。 插入文献列表 使用下列命令在文档当前位置插入文献列表： 12\\bibliographystyle&#123;plain&#125;\\bibliography&#123;references&#125; 参考文献写在 references.bib 里。 参考文献标注 使用 \\cite&#123;citationkey&#125; 来在你想要引用文献的地方插入一个标注。如果你不希望在正文中插入一个引用标注，但仍想要在文献列表中显示这次引用，使用 \\nocite&#123;citationkey&#125; 命令。 想要在引用中插入页码信息，使用方括号：\\cite[p. 215]&#123;citationkay&#125;。 要引用多个文献，使用逗号分隔：\\cite&#123;citation01,citation02,citation03&#125;。 引用格式 数字标号引用 LaTeX 包含了多种行内数字标号引用的格式： Plain 方括号包裹数字的形式，如 \\([1]\\)。文献列表按照第一作者的字母表顺序排列。每一个作者的名字是全称。 Abbrv 与 plain 是相同的，但作者的名字是缩写。 Unsrt 与 plain 是相同的，但文献列表的排序按照在文中引用的先后顺序排列。 Alpha 与 plain 一样，但引用的标注是作者的名字与年份组合在一起，不是数字，如 \\([Kop10]\\)。 作者日期引用 如果你想使用作者日期的引用，使用 natbib 包。它使用 \\citep&#123;...&#125; 命令来生成一个方括号标注，如 \\([Koppe,2010]\\)，使用 \\citet&#123;...&#125; 来生成一个标注，只把年份放到方括号里，如 \\(Koppe [2010]\\)。在此 查看它的更多用法。 Natbib 包也有三种格式：plainnat，abbrvnat 和 unsrtnat，他们与 plain，abbrv 和 unsrt 的效果是一样的。 其他引用格式 如果你需要使用不同的格式，你需要在同一个文件夹下创建一个格式文件（.bst 文件），引用这个格式的时侯使用它的文件名调用 \\bibliographystyle&#123;...&#125; 命令实现。 实践 \\(\\rightarrow\\) 在同一文件夹下新建一个同名的 BibTeX 文件，用正确的格式输入参考文献的信息。\\(\\rightarrow\\) 切换到 TeX 文档，并使用 \\cite，\\bibliographystyle 和 \\bibliograph 命令来引用文献。\\(\\rightarrow\\) 编译 TeX 文件。\\(\\rightarrow\\) 切换到 BibTeX 文件，并编译（点击 Typeset 按扭）\\(\\rightarrow\\) 切换到 TeX 文件并编译它 两次，然后核对 PDF 文档。 更多阅读 一份（不太）简短的 LATEX 2ε 介绍 https://github.com/CTeX-org/lshort-zh-cn/releases/download/v6.02/lshort-zh-cn.pdf 或 112 分钟了解 LaTeX 2ε. LaTeX Project http://www.latex-project.org/ Official website - has links to documentation, information about installing LATEX on your own computer, and information about where to look for help. LaTeX Wikibook http://en.wikibooks.org/wiki/LaTeX/ Comprehensive and clearly written, although still a work in progress. A downloadable PDF is also available. Comparison of TeX Editors on Wikipedia http://en.wikipedia.org/wiki/Comparison_of_TeX_editors Information to help you to choose which L A TEX editor to install on your own computer. TeX Live http://www.tug.org/texlive/“An easy way to get up and running with the TeX document production system”。Available for Unix and Windows (links to MacTeX for MacOSX users). Includes the TeXworks editor. Workbook Source Files http://edin.ac/17EQPM1 Download the .tex file and other files needed to compile this workbook. 本文译自 http://www.docs.is.ed.ac.uk/skills/documents/3722/3722-2014.pdf，依据其他文献略有修改。","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"}]},{"title":"数据平台DA@IDSM","date":"2022-09-02T07:03:22.000Z","path":"wiki/数据平台DA-IDSM/","text":"DA@IDSM 是一个高效的数据存储分析平台。截止2022年4月，平台共存储了近 32 万条云盘订阅信息以及近 16 亿条云盘负载信息。平台使用 Elasticsearch 提供基本的查询服务，并结合 Django + Nginx 实现的 API 接口来提供常用的数据分析服务。 如何使用 在连接 HUST 校园网之后，打开浏览器输入下面的 url： 1http://222.20.96.147:49083/api/subscription/diskinfo?cluster_id=20_1360900&amp;buss_name=游戏&amp;disk_type=data&amp;all=true&amp;limit=3 它将返回如下信息（敏感信息已隐藏）： 12345678910111213141516171819202122232425262728293031&#123; &quot;data&quot;: [ &#123; &quot;id&quot;: 152470, &quot;app_id&quot;: &quot;125xxxxxx56&quot;, &quot;disk_uuid&quot;: &quot;7eexxxxx-xxxx-xxxx-xxxx-xxxxx54703cb&quot;, &quot;cluster_id&quot;: &quot;xx_xxxxx00&quot;, &quot;inst_id&quot;: &quot;disk-rcxxxxob&quot;, &quot;vm_uuid&quot;: &quot;071axxxx-xxxx-xxxx-xxxx-xxxxx8515eaa&quot;, &quot;create_date_time&quot;: &quot;2019-04-22&quot;, &quot;expire_date_time&quot;: &quot;2020-09-22&quot;, &quot;life_stat&quot;: &quot;normal&quot;, &quot;is_local&quot;: 0, &quot;disk_attr&quot;: &quot;xxxx&quot;, &quot;disk_type&quot;: &quot;data&quot;, &quot;is_vip&quot;: 1, &quot;pay_mode&quot;: &quot;prepay&quot;, &quot;pay_type&quot;: 0, &quot;vm_alias&quot;: &quot;xxxx_TEST游戏服务器6&quot;, &quot;vm_cpu&quot;: 2, &quot;vm_mem&quot;: 4, &quot;app_name&quot;: &quot;xxxx_TEST游戏服务器&quot;, &quot;project_name&quot;: null, &quot;disk_name&quot;: &quot;未命名_2&quot;, &quot;disk_usage&quot;: 1024, &quot;disk_size&quot;: 100 &#125;, &#123;...&#125;, &#123;...&#125; ]&#125; 解析：222.20.96.147 为实验室服务器网关地址， 49083 为本数据平台 API 接口的端口号。该请求返回仓库号为 20_1360900、 磁盘类型为 data、业务标签中含有 「游戏」字段的前三个云盘订阅信息。 它能做些什么 数据平台支持快速的时序数据处理，目前平台内已经支持对海量云盘负载数据的分析计算。 如果你需要经常写一些分析程序来处理数据，或者生成一些数据分析图像，那么这个平台将非常有用。同时，这些数据也使得多人共享更为方便。 总体结构 目前平台的总体结构如下图所示： 云盘订阅信息是非时序数据，放在 MySQL 中，云盘负载信息是时序数据，放在 ElasticSearch 中。常用的数据处理需求由 Django 实现。","categories":[{"name":"资源","slug":"resource","permalink":"https://dsis-scss.github.io/categories/resource/"},{"name":"数据","slug":"resource/数据","permalink":"https://dsis-scss.github.io/categories/resource/%E6%95%B0%E6%8D%AE/"}]},{"title":"机器学习学习笔记（持续更新）","date":"2022-09-01T03:00:00.000Z","path":"wiki/机器学习笔记/","text":"What is ML? In short, ML is to Look for a function and to obtain an answer to a certain question, applied in speech recognition, image recognition. Different types of ML Regression: output a scalar. Classification: given classes, output correct one. E.g. alpha go. Structured learning：create something with a structure. How to find a function? Give a function with unknown paraments, called model. \\[ y = b+wx_1 \\] Symbol \\(x_1\\) is called feature.Symbol \\(w\\) and \\(b\\) represent weight and bias. Define loss from Training Data. Loss is a function of parameters \\(b\\) and \\(w\\). It evaluates how good a set of values is. Paint error surface. Optimization: Gradient Descent for example. The process of finding a function is called training. New model Sometimes linear functions are inaccurate, so we need to use a new model to construct function with parameters. ### From linear model, to piecewise linear model. Use Sigmoid Function to approximately express Hard Sigmoid Function, and add multiple Sigmoid Function to express piecewise linear model. Then we can express function as: \\[ y = b + \\sum_ic_i\\ sigmoid(b_i+\\sum_jw_{ij}x_j) \\] We use vector \\(\\theta\\) to express all the parameters in the function above, then the Loss function can be expressed as \\(L(\\theta)\\). After that, we do the optimization to find the \\(\\theta^*\\) satisfying \\(\\theta^*=arg\\ {min}_{\\theta}\\ L\\) What is the general guide on ML? A general guide It can be described as the picture followed. Large training loss Training loss is large. It may result from: 1. Model bias It means that the model is too simple. Solution: redesign more features or deep learning 2. Optimization issue How to know whether optimization causes a large training loss? Start from shallower networks (or other models), which are easier to optimize. If deeper networks do not obtain smaller loss on training data, then there is optimization issue. Small training loss, but large testing loss. Testing loss is large. It may result from: #### 1. Overfitting Overfitting occurs when loss is small on training data, but large on testing data. Solutions: a. more training data, or data augmentation; b. Constrained model: model has less flexibility. Bias-complexity trade-off Cross validation: divide training set into training set and validation set. Use validation set to test the loss of the function obtained from training data set. How to split the training set? N-fold cross validation 2.Mismatch Mismatch occurs when your training data and testing data have different distributions.Its difference from overfitting is that more training data can not obtain a better result. How to find a function? Give a function with unknown paraments, called model. \\[ y = b+wx_1 \\] Symbol \\(x_1\\) is called feature.Symbol \\(w\\) and \\(b\\) represent weight and bias. Define loss from Training Data. Loss is a function of parameters \\(b\\) and \\(w\\). It evaluates how good a set of values is. Paint error surface. Optimization: Gradient Descent for example. The process of finding a function is called training. New model Sometimes linear functions are inaccurate, so we need to use a new model to construct function with parameters. ### From linear model, to piecewise linear model. Use Sigmoid Function to approximately express Hard Sigmoid Function, and add multiple Sigmoid Function to express piecewise linear model. Then we can express function as: \\[ y = b + \\sum_ic_i\\ sigmoid(b_i+\\sum_jw_{ij}x_j) \\] We use vector \\(\\theta\\) to express all the parameters in the function above, then the Loss function can be expressed as \\(L(\\theta)\\). After that, we do the optimization to find the \\(\\theta^*\\) satisfying \\(\\theta^*=arg\\ {min}_{\\theta}\\ L\\)","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"机器学习","slug":"knowledge/机器学习","permalink":"https://dsis-scss.github.io/categories/knowledge/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"VSCode 快速上手","date":"2022-08-27T11:23:05.000Z","path":"wiki/vscode/","text":"先善其事必先利其器，使用一款好的编译器对于我们工作学习来说是至关重要的。不论你使用的是 Windows 、Mac OS 还是 Linux，我们都推荐使用 VS code(Visual Studio code) 编辑器。它是微软开发的一款开源跨平台编辑器，几乎在任何系统(甚至网页上)编辑任何语言的代码。得益于其活跃的社区，VS code 拥有非常丰富的插件，这些插件也使得我们编码体验变得更加友好。 安装 进入官网下载 点击下载 User 的 64 bit 版本。 后序安装中，下图中的两个选项都勾选上，这样后面可以直接通过文件夹打开 vs code： 配置 C++ 调试运行 安装 C++ 运行环境 C++ 有很多编辑器，Clang、GNU C++、MSVC等等。我们这里安装 GNU C++，在 Windows 中，直接安装 MinGW（Minimalist GNU on Windows）即可。如果你是 MacOS 用户，可以通过安装 Command Line Toools 来进行配置。 MinGW 推荐到 SourceForge 进行下载, 选择 8.1.0 版本的 x86_64-posix-seh 资源包文件（64位操作系统，启用 C++ 11 多线程特性等）。另外，如果想要使用最新版 GCC-11.2（支持 C++ 20，但对某些机型可能不适配，谨慎使用），可以到这里下载。 下载完成之后，直接拷贝到 G 盘（或其他盘，根据自己情况来调整）根目录下，然后将下图中的路径（g++.exe所在目录路径）复制到剪贴板： 注意，图中的 MinGW 安装在 G 盘，你需要找到你的 MinGW 路径，打开其中的 bin 文件夹，复制其路径即可。 然后，将复制的路径追加到 path 环境变量中，示意图如下： 如果你在上面的过程中遇到了问题，可以参考该链接中提供的方法：https://new.qq.com/omn/20211202/20211202A08CCW00.html 如果你是 win7 用户，同样可以通过百度来找到对应的修改办法，但要特别注意追加环境变量时的逗号分隔符是英文。 配置环境变量是为了在其他地方都可以用到 bin 目录下的 exe 文件（例如 g++.exe）。 你可通过以下方式检验是否安装成功： 如果你测试的结果与上面的不同，说明环境变量配置失败了，需要重新检查一下前面的步骤，如果实在不行，不妨重启一下电脑试试。 配置 VS Code 运行环境 到了最复杂的一步，由于 VS Code 有着庞大的社区，各种各样的插件、配置会让你感觉到眼花缭乱。这里首先教大家如何在 VS Code 中通过命令行终端（Terminal）中编译运行 C++ 代码，然后再配置如何实现单步调试功能。 安装插件 在这一步，你需要用各种插件来丰富你的 VS Code。打开 VS Code，在左侧工具栏中寻找下图样式的按钮（不要在意按钮的顺序，因为图中已经安装了很多别的插件） 然后在搜索框中输入对应的插件名，点击下载按钮即可。 汉化插件 Chinese C/C++ 插件 Code Runner 安装完 Code Runner 之后，我们点击右下角的设置按钮，进入「扩展设置」（或者通过右上角的「文件」-「首选项」-「设置」-「搜索框中输入 Code Runner 进行查找」）。找到下图中的三项设置，勾上对钩。 然后找到下图中的设置项，点进去 settings.json，设置我们运行 C++ 时的编译命令 点击去之后，添加如下设置代码： 123456&#123; &quot;code-runner.executorMap&quot;: &#123; &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &#125;,&#125; 如果你发现点进去之后 VS Code 中已经生成了很多配置文档，不用担心，你只要确保其中有 C 和 C++ 的编译命令即可。 这里简单解释一下 cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt：$dir 表示当前文件的所在目录，cd 会将终端的工作目录切换到 $dir 下，然后对当前文件 $fileName 使用 g++ 进行编译，编译生成的文件名是 $fileNameWithoutExt，然后紧接着直接通过命令 $dir$fileNameWithoutExt运行编译好的文件。如果你不能完全理解我在说什么也没有关系，只要确保有这一条配置就可以了。 测试运行 接下来我们测试运行 C++ 代码，首先我们需要在电脑中找一个地方创建一个空的文件夹用来存放代码（最好是空的），点击左上角的「文件」，然后点击「打开文件夹」，选择刚刚创建的文件夹。 例如，我这里创建了一个名字为 CPP 的文件夹，点击按钮创建新的文件 a.cpp。 输入以下代码： 1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; return 0;&#125; 点击 Run Code 运行（或者 Ctrl + Alt + N），可以看到下面的终端输出了 Hello World!11 ，运行成功！ 到此为止，你可以通过 VS Code 来写单文件的 CPP 代码了。（如果要是多文件的 CPP 项目，建议使用 MakeFile 来编译） 调试运行 如果你不满足于终端运行，想要单步调试代码，该如何处理？ 也很简单，首先，你在 CPP 文件夹中创建一个名字为 .vscode 的文件，注意前面的点不可以被忽略，它将被 VS Code 视作配置文件。然后在里面创建两个文件： launch.json 注意下面的第 15 行配置，它对应的是你 MinGW 的安装环境，需要找到 bin 目录下的 gdb.exe 文件。注意所有的文件分隔符都是用 / 而不是 \\，如果使用 \\ 还需要将其转义为 \\\\。 1234567891011121314151617181920212223242526&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, // 调试目标文件 &quot;args&quot;: [], // 指定调试传入参数，可自行修改 &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;cwd&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;G:/Program Files/mingw64/bin/gdb.exe&quot;, // /path/to/gdb &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;build-g++&quot; // 每次调试前 - 都进行生成任务执行编译，保证调试的目标文件是最新的 &#125; ] &#125; 注意到启动调试 （launch）之前，我们配置了 build-g++，所以还需要一个 tasks.json文件。 tasks.json 以下内容不需要修改，直接复制粘贴即可。 12345678910111213141516171819202122232425262728293031323334353637383940&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build-g++&quot;, // 给当前的生成任务一个名字 &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ // 如果你以后对于编译参数有任何修改，就在这里修改。 &quot;-g&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasename&#125;&quot;, // $&#123;fileBasenmae&#125; VS Code 内置变量: 当前活动文件的完整文件名 - helloworld.cpp &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, // $&#123;fileBasenameNoExtension&#125; 这个是 VS Code 内置变量: 当前活动文件的完整文件名舍去扩展名 - helloworld &quot;-Wall&quot; // 开启全部警告 ], // 错误消息获得 - 正则表达式 &quot;problemMatcher&quot;: &#123; &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [ &quot;relative&quot;, // &quot;$&#123;workspaceRoot&#125;&quot; &quot;\\\\&quot; ], &quot;pattern&quot;: &#123; &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 &#125; &#125;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, // 指定当前任务类型 &quot;isDefault&quot;: true // 设置为默认任务 &#125; &#125; ] &#125; 配置完成后，你的文件结构应该是这样的（注意 a.cpp 在 CPP 中，而不是在 .vscode 中）： 为了测试方便， 我们写了下面这份代码演示调试流程，代码含义是计算 1~ 10 的和： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int sum = 0; for(int i = 1; i &lt;= 10; i++) &#123; sum += i; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 想要在调试过程中在某条语句处停下，你需要在对应的行前面打上断点，不打断点的话，调试和直接运行并没有明显差异： 然后按 F5，或者点击右上角的三角形选择调试，进入调试。 调试过程中，你可以按 F10 来逐步执行代码，并监控每个变量的值。 如下图所示，我们运行到了 i = 6 这一步，第 7 行代码高亮，这表示 sum += i 还没有执行，这时 sum 只累加了 1 ~ 5，所以 sum = 15。 到此为止，你可以畅快的使用 VS Code 来编写 C++ 代码了！ 其他 插件 Material Icon Theme 该插件可以美化图标，让你的代码项目结构更加清晰。 Community Material Theme 主题美化插件 indent-rainbow 缩进高亮显示，代码结构更加清晰 Bracket Pair Colorizer 2 彩虹括号 详细配置教程：https://blog.csdn.net/hazelnut_x/article/details/108910971 Python VS Code 也可以用来编写 Python，它的配置方法可以参考这里：Python in VS Code 除了编写基本的python，你也可以通过安装 jupyter 插件来方便的编写 ipynb 文件。Python + Jupyter Go VS Code for Go","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"}]},{"title":"Anaconda&Jupyter快速上手","date":"2022-08-10T13:20:39.000Z","path":"wiki/Anaconda-jupyter快速上手/","text":"conda是一个python虚拟环境管理软件，它允许你为每一个python项目创建独立的环境，如果你被python的环境问题折磨过，那么你就会知道conda有多好用。而Anaconda则是python的一个发行版本，也是conda的图形化版本。有了Anaconda，每次在运行一个新的python项目时，你都应该重新创建一个python env，并且在该env下安装python包、执行命令 安装Anaconda(conda) 推荐清华源下载最新的版本，或者合适的版本，注意选择合适你的操作系统和处理器架构的安装包。如果是在没有图形界面的服务器上，推荐安装Miniconda Anaconda的安装有图形化界面，在此就不再赘述，没有特殊要求的话，使用默认配置一路点继续就可以了，需要注意的是，在安装过程中记得勾选将conda配置进系统环境变量中 Miniconda安装包下载下来之后是一个.sh脚本文件，对其添加执行文件后，直接利用bash执行然后按照步骤安装即可 123wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda-x.x.x-Linux-x86_64.shsudo +x Miniconda-x.x.x-Linux-x86_64.sh./Miniconda-x.x.x-Linux-x86_64.sh 注意Miniconda安装时它会询问你是否要运行conda init，请选择yes，此步的作用是将conda的配置写入你的shell配置文件中，安装完成后，可以查看你的shell配置文件是否包含 1234567891011121314# &gt;&gt;&gt; conda initialize &gt;&gt;&gt;# !! Contents within this block are managed by &#x27;conda init&#x27; !!__conda_setup=&quot;$(&#x27;/Users/xingguangjie/opt/anaconda3/bin/conda&#x27; &#x27;shell.zsh&#x27; &#x27;hook&#x27; 2&gt; /dev/null)&quot;if [ $? -eq 0 ]; then eval &quot;$__conda_setup&quot;else if [ -f &quot;/Users/xingguangjie/opt/anaconda3/etc/profile.d/conda.sh&quot; ]; then . &quot;/Users/xingguangjie/opt/anaconda3/etc/profile.d/conda.sh&quot; else export PATH=&quot;/Users/xingguangjie/opt/anaconda3/bin:$PATH&quot; fifiunset __conda_setup# &lt;&lt;&lt; conda initialize &lt;&lt;&lt; 如果没有的话，就无法正常执行conda指令，请重新安装或者切换到conda的安装目录中（执行安装脚本的时候有写），手动执行conda init 1./conda init 完成安装后，在终端中输入conda --versin可正常运行即可（Windows可以在开始-应用程序中找到anaconda prompt作为终端使用） conda常用命令 有了Anaconda，就可以在Anaconda Navigator里面创建虚拟环境、安装包等等，但是不推荐使用，更加常见的方式还是直接通过命令行与conda交互，下面列举几条常见的命令 激活一个环境（切换到已有的环境中） 1conda activate base # 切换到名字为base的环境下（刚刚安装好conda没有创建新环境的情况下默认只有base环境） 从环境中退出 1conda deactivate 创建一个新环境，并且指定环境的python版本 1conda create -n test python=3.7 # 创建python版本为3.7的名为test的环境 删除一个环境 1conda remove test # 删除一个名为test的环境 在特定的环境中安装包 123conda activate testpip install numpy&gt;=3.7 # 通过pip安装版本号高于3.7的numpy包conda install numpy&gt;=3.7 # 通过conda安装版本号高于3.7的numpy包 配置Jupyter jupyter是一个开源的python交互式web应用，最大的用处就是可以一行一行运行python代码，并且实时的将一些数据或者图表打印出来，有助于debug以及数据分析 首先安装jupyter 12conda activate testconda install jupyter # 在名为test的环境下安装jupyter 推荐使用conda安装，它会帮你把所有的依赖都安装好 安装完成后，即可在安装的环境下直接运行jupyter-notebook命令，会自动打开一个浏览器窗口，同时在终端中出现一个本地url，访问这个url即可进入jupyter服务 jupyter中的基本单元是代码块，代码都是一块一块执行的，在代码块中编写代码，然后按shift-Enter即可完成执行这一块的代码，并且产生输出 在服务器中使用jupyter 如果使用云端服务器，则可以配置服务器端口转发实现本地运行服务器端jupyter服务（例如服务器端有完善的python环境或者需要使用服务器GPU运行调试某些python代码） 配置比较简单，可以参考 Jupyter notebook远程连接服务器 Jupyter Notebook服务器配置","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"}]},{"title":"文献管理工具-Zotero","date":"2022-08-10T01:15:57.000Z","path":"wiki/文献管理工具-Zotero/","text":"Zotero介绍 官方网站：Zotero | Your personal research assistant Zotero是一个免费软件，可以帮助你进行文献的收集、整理、注释和引用。 Zotero具有较高的自由度，有许多插件可供选择。 下载与安装 本体 可在Zotero官网下载安装包 运行安装包，选择安装位置即可 浏览器插件-Zotero Connector Zotero Connector可以从网页中抓取文献和元数据，将其保存到本地。只有Zotero运行时Zotero Connector才能使用。 Zotero Connector支持Edge、Chrome、火狐、Safari浏览器 Zotero Connector下载链接 Edge、Chrome插件可在对应浏览器的插件引用市场获取 火狐、Safari的插件安装方法可参考下载页面 插件 打开【Zotero】 点击【工具】—【插件】 将需要安装的插件【拖动】至该页面 安装完毕后重启【Zotero】 推荐插件 ZotFile：自动修改附件名、添加附件 官方网站：ZotFile - Advanced PDF management for Zotero Github仓库：jlegewie/zotfile: Zotero plugin to manage your attachments 茉莉花：抓取中文网站元数据 GIthub仓库：l0o0/jasminum: A Zotero add-on to retrive CNKI meta data 配置 在线同步 打开【Zotero】—【编辑】—【首选项】—【同步】 在【数据同步】栏创建并登录Zotero账号 在【文件同步】栏，可以使用Zotero文件同步服务的300MB免费空间，也可以使用支持WebDAV的云盘，这里使用坚果云为例，坚果云免费账号每月提供1GB上传流量和3GB下载流量，足够用于文献同步 进入坚果云官网，创建并登陆账号，进入【账户信息】—【安全选项】 点击添加应用，输入名称（如Zotero），点击生成密码 将服务器地址、账户、密码复制入【Zotero】设置界面的【文件同步】栏 PDF下载-sci-hub 打开【Zotero】—【编辑】—【首选项】—【高级】—【常规】—【设置编辑器】 接受风险，搜索找到【extensions.zotero.findPDFs.resolvers】 双击编辑，将默认的[]替换为 123456789&#123; &quot;name&quot;:&quot;Sci-Hub&quot;, &quot;method&quot;:&quot;GET&quot;, &quot;url&quot;:&quot;https://sci-hub.hkvisa.net/&#123;doi&#125;&quot;, &quot;mode&quot;:&quot;html&quot;, &quot;selector&quot;:&quot;#pdf&quot;, &quot;attribute&quot;:&quot;src&quot;, &quot;automatic&quot;:true &#125; 其中【https://sci-hub.hkvisa.net】为可用的sci-hub链接 设置完成后可通过ISBN、DOI等下载PDF 也可以在Zotero Connector无法抓取PDF时，右键点击条目手动下载PDF ZotFile 进入【Zotero】—【工具】—【ZotFile Preferences…】 【General Settings】设置更加方便的向条目中添加附件，但个人感觉实用性不强，设置可参考文末的参考链接Zotero：科研小白的第一款文献管理软件 - 知乎 (zhihu.com) 【Tablet Settings】设置与云盘的同步，并实现跨平台同步，设置方法同样参考文末链接Zotero：科研小白的第一款文献管理软件 - 知乎 (zhihu.com) 【Renaming Rules】设置通过规则语句对PDF、DOC等文件进行重命名，规则语句的编写格式参考ZotFile的说明 【Advanced Settings】对重命名进行进阶设置，可以不动 茉莉花 还没用过，待补充 使用实例 在网页中找到需要的文献，点击【Zotero Connector】，可在弹出的页面将本文献的条目归档至某文件夹，并添加tag。这里将文献归档至【TEST】文件夹并添加tag【00】代表未读 可以看到我们刚刚添加的文献，两个文件分别是文献的PDF和网页快照，双击即可打开，此外可在右侧设置文献条目的信息 在阅读文献的过程中做的笔记以及其他相关资料，可以以【附件】的形式添加到文献条目中 左下角的展示的是文献的tag，可以通过指派颜色管理常用的tag，如已读、未读等，右键点击代表已读的tag【Read】，选择指派颜色，即可将其设置为蓝色，快捷键设为【2】，之后就可以通过键盘【2】快速更改条目的阅读状态 参考链接 Zotero | Your personal research assistant Zotero：科研小白的第一款文献管理软件 - 知乎 (zhihu.com) 坚果云官网|网盘|云盘|云服务|团队协作软件|同步盘 (jianguoyun.com) ZotFile - Advanced PDF management for Zotero l0o0/jasminum: A Zotero add-on to retrive CNKI meta data. 一个简单的Zotero 插件，用于识别中文元数据 (github.com)","categories":[{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"},{"name":"科研软件","slug":"tools/科研软件","permalink":"https://dsis-scss.github.io/categories/tools/%E7%A7%91%E7%A0%94%E8%BD%AF%E4%BB%B6/"}]},{"title":"时序预测论文整理","date":"2022-07-28T08:39:34.000Z","path":"wiki/时序预测论文整理/","text":"Tittle Algorithm Idea classical methods An adaptive prediction approach based on workload pattern discrimination in the cloud An adaptive approach categorizes the workloads into different classes which are automatically assigned for different models according to workload features TODO Exponential Smoothing(ES) A Hierarchical Framework for Modeling and Forecasting Web Server Workload Auto Regression(AR) A linear combination of past values of the variable under consideration is used to forecast the value for upcoming time instances. Dual time-scale distributed capacity allocation and load redirect algorithms for cloud systems Moving Average(MA) non-linear optimization The model is appropriate for time series exhbiting seasonal behavior only Efficient autoscaling in the cloud using predictive models for workload forecasting Autoregressive Integrated Moving Average(ARIMA) also discussed the challenges involved in auto scaling in a cloud environment Workload Prediction Using ARIMA Model and Its Impact on Cloud Applications’ QoS Autoregressive Integrated Moving Average(ARIMA) ARIMA on different confidence interval to predict web server workload Workload characterization and prediction in the cloud: A multiple time series approach Hidden Markov Model distinguish the temporal correlations in obtained clusters of VMs A workload analysis of live event broadcast service in cloud Regression techniques the approach is based on simple statistical models that might not capture the patterns in more complex data Workload characterization and prediction in the cloud: A multiple time series approach multiple time series approch The model does a grouping of similar applications's need in order to improve the accuracy of predictions machine learning methods Support vector machines experts for time series forecasting Self organizing map(SOM) and support vector machines(SVMs) Self organizing map was used to cluster the data in different regions while SVMs were used to predict the future data Referential kNN Regression for Financial Time Series Forecasting \\(k\\) Nearest Neighbors(kNN) For financial time series prediction. kNNs are lazy learners and need high computational cost Hierarchical neural networks based prediction and control of dynamic reconfiguration for multilevel embedded systems the Neural network used to model workload variations in multimidia designs A cost-aware auto-scaling approach using the workload prediction in service clouds Linear regression the predicted workload was used to decide the type of scaling Efficient resources provisioning based on load forecasting in cloud Support Vector Regression(SVR) and Kalman smoother It achieved high prediction accuracy Combining time series prediction models using genetic algorithm to autoscaling Web applications hosted in the cloud infrastructure Ensemble based model It uses five different base prediction models. Each model is assigned a weight and contributes accordingly in predictions. The weight are assigned and optimized using genetic algorithm Empirical prediction models for adaptive resource provisioning in the cloud Neural network and Linear regression RVLBPNN: A Workload Forecasting Model for Smart Cloud Computing back propagation learning algorithm It adjusts the weights of model according to error trend. A Predictive Method for Workload Forecasting in the Cloud Environment neural network and steepest descent learning algorithm suffers from high prediction errors. Workload prediction in cloud using artificial neural network and adaptive differential evolution neural network and adaptive differential evolution","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"论文","slug":"knowledge/论文","permalink":"https://dsis-scss.github.io/categories/knowledge/%E8%AE%BA%E6%96%87/"}]},{"title":"分布式系统入门(MIT 6.824)","date":"2022-07-27T09:02:26.000Z","path":"wiki/分布式系统入门/","text":"MIT6.824课程主页 http://nil.csail.mit.edu/6.824/2022/ 课程安排 http://nil.csail.mit.edu/6.824/2022/schedule.html 论文翻译 MapReduce (2004) GFS (2003) Fault-Tolerant Virtual Machines (2010) Raft (2014) lab参考 SwordHarry/MIT6.824_2021_note 参考书目 DDIA-设计数据密集型应用","categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"体系结构","slug":"knowledge/体系结构","permalink":"https://dsis-scss.github.io/categories/knowledge/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"DDIA-设计数据密集型应用","date":"2022-07-27T09:01:14.000Z","path":"wiki/DDIA-设计数据密集型应用/","text":"书名 《Designing Data-Intensive Applications》 简介 现今，尤其是在互联网领域，大多数应用都属于数据密集型应用。本书从底层数据结构到顶层架构设计，将数据系统设计中的精髓娓娓道来。其中的宝贵经验无论是对架构师、DBA、还是后端工程师、甚至产品经理都会有帮助。 实验室有一部分研究是在分布式多机系统下的数据存储与管理，特别是应用于云硬盘系统的存储管理，该书可以有助于理解数据密集型应用所需要考虑的问题，发现可以优化的点，以及对于分布式架构有所了解。 中文翻译 设计数据密集型应用 - 中文翻译","categories":[{"name":"资源","slug":"resource","permalink":"https://dsis-scss.github.io/categories/resource/"},{"name":"书目","slug":"resource/书目","permalink":"https://dsis-scss.github.io/categories/resource/%E4%B9%A6%E7%9B%AE/"}]}],"categories":[{"name":"知识","slug":"knowledge","permalink":"https://dsis-scss.github.io/categories/knowledge/"},{"name":"操作系统","slug":"knowledge/操作系统","permalink":"https://dsis-scss.github.io/categories/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"工具","slug":"tools","permalink":"https://dsis-scss.github.io/categories/tools/"},{"name":"资源","slug":"resource","permalink":"https://dsis-scss.github.io/categories/resource/"},{"name":"数据","slug":"resource/数据","permalink":"https://dsis-scss.github.io/categories/resource/%E6%95%B0%E6%8D%AE/"},{"name":"机器学习","slug":"knowledge/机器学习","permalink":"https://dsis-scss.github.io/categories/knowledge/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"科研软件","slug":"tools/科研软件","permalink":"https://dsis-scss.github.io/categories/tools/%E7%A7%91%E7%A0%94%E8%BD%AF%E4%BB%B6/"},{"name":"论文","slug":"knowledge/论文","permalink":"https://dsis-scss.github.io/categories/knowledge/%E8%AE%BA%E6%96%87/"},{"name":"体系结构","slug":"knowledge/体系结构","permalink":"https://dsis-scss.github.io/categories/knowledge/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"书目","slug":"resource/书目","permalink":"https://dsis-scss.github.io/categories/resource/%E4%B9%A6%E7%9B%AE/"}],"tags":[]}